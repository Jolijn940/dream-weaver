<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dream Weaver</title>
  <style>
    /*
     * Basiskleuren voor de UI.  De variabele --panel-bg wordt gebruikt voor de
     * achtergrond van kaarten, knoppen, pillen en formulieren.  De standaard
     * waarde (#0b1220) correspondeert met de huidige donkere achtergrond.  Dit
     * kan door de gebruiker worden aangepast via de achtergrondinstellingen.
     */
    :root{--b:#334155;--ui-opacity:1;--aside-opacity:1;--text-color:#e5e7eb;--panel-bg:#0b1220}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,Segoe UI,Arial;background:#0f172a;color:var(--text-color)}

    /* wanneer paneelachtergrond uitgeschakeld is, maak containers transparant */
    body.noPanels aside,
    body.noPanels nav,
    body.noPanels header,
    body.noPanels footer,
    body.noPanels .toolbar,
    body.noPanels .list,
    body.noPanels .box,
    body.noPanels .pill,
    body.noPanels dialog form,
    body.noPanels #content > div {
      background: transparent !important;
      backdrop-filter: none !important;
      box-shadow: none !important;
      border-color: rgba(255,255,255,0.2) !important;
    }

    /* highlight voor zoekresultaten in agenda */
    .pill.highlight {
      animation: highlight-fade 3s forwards;
      background-color: rgba(255, 255, 0, 0.2) !important;
    }

    /* highlight voor zoekresultaten in kalender */
    .stripe.highlight {
      animation: highlight-fade 3s forwards;
      background-color: rgba(255, 255, 0, 0.2) !important;
    }
    @keyframes highlight-fade {
      0% { background-color: rgba(255,255,0,0.5); }
      100% { background-color: rgba(255,255,0,0); }
    }
    .app{display:grid;grid-template-columns:200px 1fr;min-height:100vh;position:relative;z-index:1}
    aside{background:var(--aside-bg, #111827);padding:10px;opacity:var(--aside-opacity, 1)}
    nav a{display:block;padding:6px 8px;border-radius:6px;color:inherit;text-decoration:none}
    nav a.active,nav a:hover{background:#1f2937}
    /* Gebruik de paneelkleur voor de header in de donkere modus */
    header{background:var(--panel-bg);color:#fff;padding:6px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--b)}
    .btn{padding:4px 8px;border:1px solid var(--b);border-radius:6px;background:var(--panel-bg);color:#e5e7eb;cursor:pointer}
    .btn.v.active{background:#1f2937}
    /* Gebruik de paneelkleur voor kaarten */
    .card{padding:10px;background:var(--panel-bg);border:1px solid var(--b);border-radius:8px;margin:10px}
    .pill{display:flex;align-items:center;gap:6px;justify-content:space-between;border:1px solid var(--b);background:var(--panel-bg);padding:4px 6px;border-radius:8px;margin:4px 0;font-size:13px}
    .pill.done{opacity:.6;text-decoration:line-through}
    .stripe{display:block;height:7px;border-radius:4px;margin:3px 0;border:1px solid #ffffff22;cursor:pointer}
    /* Formuliervelden gebruiken dezelfde paneelkleur als achtergrond */
    input,select,textarea{width:100%;padding:6px;border-radius:6px;border:1px solid var(--b);background:var(--panel-bg);color:#e5e7eb}
    label{font-size:12px;opacity:.9}
    .bg{position:fixed;inset:0;z-index:0;opacity:1;background-size:cover;background-position:center;pointer-events:none;transition:background-image .3s}
    /* Zorg ervoor dat achtergrondafbeeldingen aanzienlijk scherper worden weergegeven.
       Gebruik vendor-specifieke optimalisatie voor WebKit en voorkom onnodige vervaging. */
    .bg, #bgOverlay {
      /* WebKit-optimalisatie voor maximale scherpte */
      image-rendering: -webkit-optimize-contrast;
      /* Gebruik crisp-edges als algemene fallback zodat afbeeldingen niet worden vervaagd bij schaling */
      image-rendering: crisp-edges;
    }
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
    .chk{display:inline-flex;align-items:center;gap:6px;padding:2px 6px;border:1px solid var(--b);border-radius:999px}
    .header-controls{display:flex;flex-wrap:wrap;gap:4px;align-items:center}

    /* Gebruik de instelbare tekstkleur voor vrijwel alle tekst-elementen */
    body, aside, nav a, nav a.active, nav a:hover, header, .btn, .card, .pill, .pill.done, input, select, textarea, label, .toolbar, .chk, .header-controls button, h1, h2, h3, h4, h5, h6 {
      color: var(--text-color) !important;
    }
    /* Light theme */
    /* In de lichte modus wordt geen vaste tekstkleur gezet; deze volgt de gekozen kleur */
    body.light{background:#f8fafc; color:var(--text-color)}
    /* Gebruik de instelbare zijbalkkleur ook in de lichte modus */
    body.light aside{background:var(--aside-bg, #f3f4f6);color:var(--text-color)}
    body.light nav a.active, body.light nav a:hover{background:#e5e7eb}
/* In lichte modus gebruiken we dezelfde paneelachtergrondvariabele zodat gebruikers hun voorkeur voor panelen kunnen doorgeven. */
body.light header{background:var(--panel-bg);color:#111827;border-bottom:1px solid #cbd5e1}
body.light .card, body.light .pill{background:var(--panel-bg);color:#111827;border-color:#cbd5e1}
body.light .btn{background:var(--panel-bg);color:#111827;border-color:#cbd5e1}
body.light .stripe{border-color:#00000022}
body.light input, body.light select, body.light textarea{background:var(--panel-bg);color:#111827;border-color:#cbd5e1}
    body.hasimg{background:transparent !important}
    body.light.hasimg{background:transparent !important}
  </style>

  <!--
    Responsieve styling
    De volgende CSS-regels zorgen ervoor dat deze planner zowel op desktop als mobiele
    apparaten goed werkt. Op kleinere schermen (max-width: 768px) wordt de zijbalk
    verborgen en kan de gebruiker via een knop in de header het menu openen of
    sluiten. De lay-out wordt aangepast naar een enkelkolomstructuur zodat de
    inhoud leesbaar blijft op mobiele apparaten.
  -->
  <style>
    /* standaard verberg de menu-knop; deze wordt geactiveerd in de media query */
    .menu-toggle {
      display: none;
    }

    @media (max-width: 768px) {
      /* Toon de menu-knop binnen de header op kleinere schermen */
      .menu-toggle {
        display: inline-block;
        background: none;
        border: none;
        color: inherit;
        font-size: 1.5rem;
        margin-right: 8px;
        cursor: pointer;
      }
      /* Zet de grid van .app naar enkel kolom voor meer ruimte */
      .app {
        grid-template-columns: 1fr;
      }
      /* Positioneer de zijbalk buiten beeld en laat hem inschuiven wanneer nav-open actief is */
      aside {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        width: 240px;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        z-index: 1000;
        overflow-y: auto;
      }
      body.nav-open aside {
        transform: translateX(0);
      }
      /* Maak overlay wanneer menu geopend is */
      body.nav-open::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
      }
      /* Zorg dat het hoofdgedeelte de volle breedte gebruikt */
      main {
        width: 100%;
      }
      /* Zorg dat header-controls eventueel wrapt op kleinere schermen */
      .header-controls {
        gap: 4px;
        flex-wrap: wrap;
      }
    }
  </style>
</head>
<body>
  <div id="bg" class="bg"></div>
  <!-- overlay element for background images with adjustable opacity -->
  <div id="bgOverlay" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1;background-size:cover;background-position:center;pointer-events:none;opacity:1"></div>
  <div class="app">
    <aside>
      <h3>Dream Weaver</h3>
      <!-- Datum boven de klok -->
      <div id="date" style="font-size:14px;color:#94a3b8;margin:4px 0"></div>
      <!-- Klok toont de huidige tijd; de datum wordt erboven weergegeven -->
      <div id="clock" style="font-size:12px; opacity:0.8; margin-top:2px;"></div>
      <nav id="menu">
        <a href="#kalender" data-route="kalender" class="active">üìÖ Kalender</a>
        <a href="#huiswerk" data-route="huiswerk">üìÑ Huiswerk</a>
        <a href="#toetsen" data-route="toetsen">üìù Toetsen</a>
        <!-- Foutenlijst verwijderd -->
        <a href="#leren" data-route="leren">üìñ Leren</a>
        <a href="#extra" data-route="extra">üß© Extra</a>
        <a href="#agenda" data-route="agenda">üìÜ Agenda</a>
        <a href="#notities" data-route="notities">üìî Notities</a>
        <a href="#cijfers" data-route="cijfers">üìä Cijfers</a>
        <a href="#relax" data-route="relax">üéÆ Relax</a>
        <a href="#achtergrond" data-route="achtergrond">üñºÔ∏è Achtergrond</a>
        <a href="#instellingen" data-route="instellingen">‚öôÔ∏è Instellingen</a>
        <!-- Nieuw login/account menu-item -->
        <a href="#account" data-route="account">üîê Login</a>
      </nav>
    </aside>
    <main>
      <header>
        <!-- Navigatieknop voor mobiel. Dit knopje verschijnt alleen op kleinere schermen
             via de CSS-regels onderaan. Het schakelt de klasse 'nav-open' op <body>
             zodat de zijbalk (aside) naar binnen schuift.  -->
        <button class="menu-toggle" onclick="document.body.classList.toggle('nav-open')">‚ò∞</button>
        <div><strong id="title">Kalender</strong><span id="sub" style="margin-left:6px;color:#94a3b8"></span></div>
        <div id="headerControls" class="header-controls">
          <button id="prev" class="btn" title="Vorige">‚óÄ</button>
          <button id="today" class="btn">Vandaag</button>
          <button id="next" class="btn" title="Volgende">‚ñ∂</button>
          <button data-v="month" class="btn v active">Maand</button>
          <button data-v="week" class="btn v">Week</button>
          <button data-v="day" class="btn v">Dag</button>
          <button id="new" class="btn">+ Taak</button>
        </div>
      </header>
      <div id="content" class="card"></div>
    </main>
  </div>

  <!-- Taak dialoog -->
  <dialog id="dlg" style="border:none;border-radius:10px;padding:0;max-width:520px;width:clamp(300px,90vw,520px)">
    <form method="dialog" style="padding:12px;background:#1e293b;color:#e5e7eb">
      <h3 style="margin:0 0 8px">Taak</h3>
      <input type="hidden" id="tid">
      <label>Titel</label>
      <div style="display:flex;gap:6px;align-items:center">
        <input id="ttitle"><button type="button" class="btn" id="micTitle">üéôÔ∏è</button><button type="button" class="btn" id="speakTitle">üîä</button>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:6px">
        <div><label>Datum</label><input id="tdate" type="date"></div>
        <!-- Extra veld voor multi-daagse taken: einddatum -->
        <div><label>Einddatum</label><input id="tenddate" type="date"></div>
        <div><label>Kleur</label><input id="tcolor" type="color" value="#3b82f6"></div>
        <div><label>Start</label><input id="tstart" type="time"></div>
        <div><label>Einde</label><input id="tend" type="time"></div>
        <div><label>Categorie</label>
          <select id="tcat"><option>anders</option><option>huiswerk</option><option>toets</option><option>leren</option><option>extra</option></select>
        </div>
        <div><label>Herhaling</label>
          <select id="trepeat">
            <option value="none">geen</option>
            <option value="daily">elke dag</option>
            <option value="2d">om de 2 dagen</option>
            <option value="3d">om de 3 dagen</option>
            <option value="weekly">elke week</option>
            <option value="2w">om de 2 weken</option>
            <option value="3w">om de 3 weken</option>
            <option value="monthly">elke maand</option>
            <option value="2m">om de 2 maanden</option>
            <option value="3m">om de 3 maanden</option>
            <option value="yearly">elk jaar</option>
          </select>
        </div>
      </div>
      <!-- Bestanden upload en preview -->
      <div style="margin-top:6px">
        <label>Bestanden</label>
        <input id="tfiles" type="file" multiple>
        <div id="filePreview" style="font-size:12px;margin-top:4px"></div>
      </div>
      <div style="display:flex;gap:6px;justify-content:space-between;margin-top:10px">
        <button type="button" id="tdel" class="btn">Verwijderen</button>
        <div>
          <button type="button" class="btn" onclick="document.getElementById('dlg').close()">Annuleren</button>
          <button class="btn" id="tsave">Opslaan</button>
        </div>
      </div>
      <!-- Sectie voor subtaken -->
      <div id="subtasksSection" style="margin-top:10px">
        <label>Subtaken</label>
        <!-- Een tekstveld waarin de gebruiker subtaken kan invoeren, √©√©n per regel -->
        <textarea id="subtaskInput" style="margin-top:4px;width:100%;height:60px;resize:vertical" placeholder="Voeg subtaken toe, √©√©n per regel"></textarea>
      </div>
    </form>
  </dialog>

  <!-- Cijfer dialoog -->
  <dialog id="dlgGrade" style="border:none;border-radius:10px;padding:0;max-width:520px;width:clamp(300px,90vw,520px)">
    <form method="dialog" style="padding:12px;background:#1e293b;color:#e5e7eb">
      <h3 style="margin:0 0 8px">Cijfer</h3>
      <input type="hidden" id="gid">
      <div style="display:flex;gap:6px;align-items:center;margin-bottom:6px">
        <label style="min-width:40px">Vak</label>
        <select id="gvak" style="flex:1"></select>
        <button type="button" class="btn" id="addSubjectBtn" title="Nieuw vak toevoegen">+</button>
      </div>
      <label>Omschrijving</label>
      <input id="gdesc" placeholder="bijv. Toets hoofdstuk 3">
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:6px">
        <div><label>Cijfer</label><input id="gscore" type="number" step="0.1" min="0" max="10" placeholder="0-10"></div>
        <div><label>Weging</label><input id="gweight" type="number" step="0.1" min="0" value="1"></div>
      </div>
      <div style="display:flex;gap:6px;justify-content:space-between;margin-top:10px">
        <button type="button" id="gdel" class="btn">Verwijderen</button>
        <div>
          <button type="button" class="btn" onclick="document.getElementById('dlgGrade').close()">Annuleren</button>
          <button class="btn" id="gsave">Opslaan</button>
        </div>
      </div>
    </form>
  </dialog>

  <!-- App script -->
  <script>
    // state & helpers
    const el=id=>document.getElementById(id);
    let tasks=[], view='month', route='kalender', ref=new Date(), mini='week';
    // lijst met notities voor notitieboek
    let notes = [];
    // index van het huidige notitieblad in de boekweergave
    let noteBookIndex = 0;

    // Laad notities uit localStorage
    function loadNotes(){
      try { notes = JSON.parse(localStorage.getItem('planner.notes') || '[]'); } catch { notes = []; }
    }
    // Sla notities op naar localStorage
    function saveNotes(){ localStorage.setItem('planner.notes', JSON.stringify(notes)); }
    // Maak een nieuwe notitie aan via eenvoudige prompts
    function newNote(){
      const title = prompt('Titel van de notitie?');
      if(!title) return;
      const text = prompt('Tekst van de notitie?');
      const id = Date.now().toString(36);
      notes.push({ id, title, text });
      saveNotes();
      noteBookIndex = notes.length - 1;
      render();
    }
    // Toon boekweergave voor notitie op positie idx
    function showBook(idx){
      if(typeof idx === 'number'){
        noteBookIndex = Math.max(0, Math.min(notes.length-1, idx));
        render();
      }
    }
    // Ga naar vorige notitie in de boekweergave
    function prevNote(){
      if(!notes.length) return;
      noteBookIndex = (noteBookIndex - 1 + notes.length) % notes.length;
      render();
    }
    // Ga naar volgende notitie
    function nextNote(){
      if(!notes.length) return;
      noteBookIndex = (noteBookIndex + 1) % notes.length;
      render();
    }

    // ===== Boeken en hoofdstukken voor notities =====
    // Elke notitie wordt onderdeel van een boek. Een boek bevat een lijst met hoofdstukken (notities).
    let books = [];
    let bookIndex = 0;
    let chapterIndex = 0;
    // weergavemodus voor notities: 'library' toont alle boeken, 'book' leest een hoofdstuk, 'edit' bewerkt een hoofdstuk
    let notesView = 'library';

    function loadBooks(){
      try {
        const stored = JSON.parse(localStorage.getItem('planner.books') || '[]');
        if(Array.isArray(stored)) books = stored; else books = [];
      } catch { books = []; }
      // Converteer oude notities naar een enkel boek als boeken leeg zijn
      if(books.length === 0){
        // haal oude notities op
        let old = [];
        try { old = JSON.parse(localStorage.getItem('planner.notes') || '[]'); } catch { old = []; }
        if(Array.isArray(old) && old.length){
          books.push({ id: Date.now().toString(36), title: 'Boek 1', chapters: old.map(n=>({ id: n.id, title: n.title || '', text: n.text || '' })) });
        } else {
          books.push({ id: Date.now().toString(36), title: 'Boek 1', chapters: [] });
        }
      }
    }
    function saveBooks(){ localStorage.setItem('planner.books', JSON.stringify(books)); }
    function newBook(){
      const name = prompt('Titel van het nieuwe boek?') || `Boek ${books.length+1}`;
      books.push({ id: Date.now().toString(36), title: name, chapters: [] });
      bookIndex = books.length - 1;
      chapterIndex = 0;
      saveBooks();
      // Ga na het aanmaken van een nieuw boek direct naar de leesmodus van dit boek
      notesView = 'book';
      render();
    }
    function selectBook(i){
      bookIndex = Math.max(0, Math.min(books.length-1, i));
      chapterIndex = 0;
      // Wanneer een boek geselecteerd wordt vanuit de bibliotheek, ga naar leesmodus
      notesView = 'book';
      render();
    }
    function renameBook(){
      const b = books[bookIndex];
      if(!b) return;
      const name = prompt('Nieuwe titel voor het boek?', b.title);
      if(name){ b.title = name; saveBooks(); render(); }
    }
    function deleteBook(){
      if(books.length === 0) return;
      if(confirm('Boek verwijderen?')){
        books.splice(bookIndex, 1);
        if(bookIndex >= books.length) bookIndex = Math.max(0, books.length - 1);
        chapterIndex = 0;
        saveBooks();
        render();
      }
    }
    function newChapter(){
      const b = books[bookIndex];
      if(!b) return;
      b.chapters.push({ id: Date.now().toString(36), title: '', text: '' });
      chapterIndex = b.chapters.length - 1;
      saveBooks();
      // Ga direct naar bewerkmodus na het toevoegen van een hoofdstuk
      notesView = 'edit';
      render();
    }
    function selectChapter(i){
      const b = books[bookIndex];
      if(!b) return;
      chapterIndex = Math.max(0, Math.min(b.chapters.length-1, i));
      render();
    }
    function saveChapter(){
      const b = books[bookIndex];
      if(!b) return;
      const chapter = b.chapters[chapterIndex];
      if(!chapter) return;
      const titleEl = el('chapterTitle');
      const textEl = el('chapterText');
      if(titleEl && textEl){
        chapter.title = titleEl.value || '';
        chapter.text = textEl.value || '';
        saveBooks();
        render();
      }
    }
    function deleteChapter(){
      const b = books[bookIndex];
      if(!b) return;
      if(!b.chapters.length) return;
      if(confirm('Hoofdstuk verwijderen?')){
        b.chapters.splice(chapterIndex, 1);
        if(chapterIndex >= b.chapters.length) chapterIndex = Math.max(0, b.chapters.length - 1);
        saveBooks();
        render();
      }
    }

    // Ga terug naar het boekenoverzicht
    function enterLibrary(){
      notesView = 'library';
      render();
    }
    function searchChapters(query){
      const q = (query || '').toLowerCase();
      const list = document.getElementById('chaptersList');
      if(!list) return;
      const b = books[bookIndex];
      if(!b) return;
      b.chapters.forEach((chap, i) => {
        const el = document.getElementById('chapterItem'+i);
        if(!el) return;
        const text = (chap.title || '') + ' ' + (chap.text || '');
        el.style.display = (!q || text.toLowerCase().includes(q)) ? '' : 'none';
      });
    }
    // Subjects list for grades (predefined school subjects). Loaded from localStorage.
    let subjects=[];
    function loadSubjects(){
      try{
        const s = JSON.parse(localStorage.getItem('planner.subjects') || '[]');
        if(Array.isArray(s)) subjects = s;
      }catch{ subjects=[]; }
      if(subjects.length === 0){
        subjects = ['Wiskunde','Nederlands','Engels','Natuurkunde','Scheikunde','Biologie','Geschiedenis','Aardrijkskunde'];
        saveSubjects();
      }
    }
    function saveSubjects(){ localStorage.setItem('planner.subjects', JSON.stringify(subjects)); }

    // ===== grades (cijfers) =====
    let grades=[];
    function saveGrades(){ localStorage.setItem('planner.grades', JSON.stringify(grades)); }
    function loadGrades(){ try{ grades = JSON.parse(localStorage.getItem('planner.grades') || '[]'); }catch{ grades=[]; } }
    function newGrade(){ openGradeEdit(null); }
    function openGradeEdit(id){
      const dlg = el('dlgGrade');
      let g = id ? grades.find(x=>x.id===id) : { id: crypto.randomUUID(), vak:'', desc:'', score:'', weight:1 };
      el('gid').value = g.id;
      // populate subject select
      const vakSelect = el('gvak');
      if(vakSelect){
        vakSelect.innerHTML = '';
        // ensure current subject is included
        const all = Array.from(new Set(subjects.concat(g.vak || [])));
        all.forEach(subj => {
          const opt = document.createElement('option');
          opt.value = subj;
          opt.textContent = subj;
          vakSelect.appendChild(opt);
        });
        vakSelect.value = g.vak || (subjects[0] || '');
      }
      el('gdesc').value = g.desc || '';
      el('gscore').value = g.score || '';
      el('gweight').value = g.weight || 1;
      // Configure delete and save handlers
      el('gdel').onclick = ()=>{ if(id){ deleteGrade(id); dlg.close(); } };
      el('gsave').onclick = (e)=>{ e.preventDefault(); saveGradeFromDialog(); };
      // handle adding new subject
      const addBtn = el('addSubjectBtn');
      if(addBtn){
        addBtn.onclick = function(){
          const name = prompt('Voer de naam van het nieuwe vak in');
          if(name){
            const trimmed = name.trim();
            if(trimmed && !subjects.includes(trimmed)){
              subjects.push(trimmed);
              saveSubjects();
            }
            // heropen dialoog om lijst bij te werken
            dlg.close();
            openGradeEdit(id);
          }
        };
      }
      dlg.showModal();
    }
    function saveGradeFromDialog(){
      const g = {
        id: el('gid').value || crypto.randomUUID(),
        vak: (el('gvak').value || '').trim(),
        desc: (el('gdesc').value || '').trim(),
        score: parseFloat(el('gscore').value || '0'),
        weight: parseFloat(el('gweight').value || '1') || 1
      };
      // add subject to list if new
      if(g.vak && !subjects.includes(g.vak)){
        subjects.push(g.vak);
        saveSubjects();
      }
      const i = grades.findIndex(x=>x.id===g.id);
      if(i>=0) grades[i] = {...grades[i], ...g}; else grades.push(g);
      saveGrades();
      el('dlgGrade').close();
      render();
    }
    function deleteGrade(id){ grades = grades.filter(x=>x.id!==id); saveGrades(); render(); }
    function renderGradePillHtml(g){
      return `<div class='pill' style='border-color:#64748b'><span>${g.vak||''} ‚Äì ${g.desc||''} <small style='opacity:.7'>${g.score.toFixed(1)} (${g.weight}x)</small></span><span><button class='btn' title='Bewerken' onclick='openGradeEdit("${g.id}")'>‚úèÔ∏è</button></span></div>`;
    }
    // De functies voor het exporteren en importeren van cijfers zijn verwijderd op verzoek.

    // ===== taken export/import =====
    // Exporteer taken als JSON naar klembord
    function exportTasksJSON(){ try { const txt = JSON.stringify(tasks, null, 2); navigator.clipboard.writeText(txt).then(()=>{ alert('Taken gekopieerd naar klembord'); }); } catch(e){ alert('Kan niet exporteren: '+e.message); } }
    // Importeer taken uit JSON
    function importTasksJSON(){ const json = prompt('Plak hier de JSON met taken'); if(!json) return; try{ const arr = JSON.parse(json); if(Array.isArray(arr)){ // valideer basisvelden
          arr.forEach(o=>{ o.id = o.id || crypto.randomUUID(); o.title = o.title || 'Zonder titel'; o.date = o.date || iso(new Date()); o.color = o.color || '#3b82f6'; o.category = o.category || 'anders'; o.repeat = o.repeat || 'none'; });
          tasks = arr;
          save();
          render();
          alert('Taken ge√Ømporteerd');
        } } catch(e){ alert('Ongeldige JSON: '+e.message); } }
    // Exporteer taken naar CSV en download als bestand
    function exportTasksCSV(){ try {
        if(!tasks || tasks.length === 0){ alert('Geen taken om te exporteren'); return; }
        const header = ['Titel','Datum','Start','Einde','Categorie','Herhaling','Kleur'];
        const rows = tasks.map(t => [
          (t.title||'').replace(/"/g,'""'),
          t.date||'',
          t.start||'',
          t.end||'',
          t.category||'',
          t.repeat||'',
          t.color||''
        ]);
        let csv = header.join(',') + '\n';
        rows.forEach(r=>{ csv += r.map(x=>`"${x}"`).join(',') + '\n'; });
        const blob = new Blob([csv], { type:'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'sylvaplaner-taken.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch(e){ alert('Fout bij exporteren: '+e.message); }
    }

    // back-up functies
    function downloadBackup(){
      try {
        const data = {
          tasks,
          grades,
          bg: localStorage.getItem('planner.bg.v2') || null,
          user: localStorage.getItem('planner.localUser') || null
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'sylvaplaner-backup.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch(e) {
        alert('Fout bij het maken van back-up: ' + e.message);
      }
    }
    function uploadBackup(ev){
      const file = ev.target.files && ev.target.files[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = function(e){
        try {
          const data = JSON.parse(e.target.result);
          if(data.tasks) { tasks = data.tasks; save(); }
          if(data.grades) { grades = data.grades; saveGrades(); }
          if(data.bg) { localStorage.setItem('planner.bg.v2', data.bg); }
          if(data.user) { localStorage.setItem('planner.localUser', data.user); }
          render();
          alert('Back-up geladen');
        } catch(err) {
          alert('Ongeldige back-up: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    // notificaties voor komende taken
    function setupNotifications(){
      try{
        if(!('Notification' in window)) return;
        if(Notification.permission === 'default'){
          Notification.requestPermission();
        }
      }catch{}
    }
    function scheduleDueTasks(){
      try{
        // respecteer de gebruikersinstelling voor meldingen
        if(!getNotificationsEnabled()) return;
        if(!('Notification' in window)) return;
        if(Notification.permission !== 'granted') return;
        const now = new Date();
        const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
        const due = tasks.filter(t=>{
          if(!t.date) return false;
          const d = new Date(t.date);
          return d <= tomorrow && !t.done;
        });
        due.forEach(t=>{
          const body = `${t.title || 'Taak'} ‚Äì ${t.date}${t.start ? ' om ' + t.start : ''}`;
          try{ new Notification('Taak binnenkort', { body }); }catch(e){}
        });
      }catch{}
    }
    // beschikbaar categorie√´n voor taken (foutenlijst verwijderd)
    // De beschikbare categorie√´n voor taken. Op verzoek is de categorie 'rooster'
    // volledig verwijderd zodat deze niet meer kan worden geselecteerd bij het
    // aanmaken van een taak. Het rooster blijft wel beschikbaar als aparte
    // weergave in het zijmenu, maar er bestaat geen taakcategorie meer met die naam.
    const CATS=['huiswerk','toets','leren','extra','anders'];
    const iso=d=>{const x=new Date(d);return `${x.getFullYear()}-${String(x.getMonth()+1).padStart(2,'0')}-${String(x.getDate()).padStart(2,'0')}`};
    const sow=d=>{d=new Date(d);d.setHours(0,0,0,0);const o=(d.getDay()+6)%7;d.setDate(d.getDate()-o);return d};

    // state for filter visibility (collapsible toolbar)
    let filtersExpanded = false;
    // storage & filters
    function save(){localStorage.setItem('planner.tasks',JSON.stringify(tasks))}
    function load(){try{tasks=JSON.parse(localStorage.getItem('planner.tasks')||'[]')}catch{tasks=[]}}
    // Haal de instelling voor het verbergen van afgevinkte taken op.
    // In plaats van √©√©n globale instelling wordt de waarde nu per zijmenu-route opgeslagen.
    // Hierdoor kan de gebruiker bijvoorbeeld in de huiswerkweergave afgevinkte taken verbergen
    // terwijl ze in de toetsenweergave zichtbaar blijven.
    function getHide(){
      try{
        // bepaal huidige route (standaard 'kalender' wanneer route onbekend)
        const r = (typeof route !== 'undefined' && route) ? route : 'kalender';
        const key = 'planner.hideDone.' + r;
        return JSON.parse(localStorage.getItem(key) || 'false');
      }catch{
        return false;
      }
    }
    // Stel de instelling voor het verbergen van afgevinkte taken in voor de huidige route.
    function setHide(v){
      const r = (typeof route !== 'undefined' && route) ? route : 'kalender';
      const key = 'planner.hideDone.' + r;
      localStorage.setItem(key, JSON.stringify(!!v));
      render();
    }
    // Haal de categorie-filter op voor de huidige route. De filters worden per zijmenu opgeslagen zodat je bijvoorbeeld
    // in het rooster andere categorie√´n kunt tonen dan in de kalender.
    function getCatFilter(){
      try{
        const r = (typeof route !== 'undefined' && route) ? route : 'kalender';
        return JSON.parse(localStorage.getItem('planner.cats.' + r) || '{}');
      }catch{
        return {};
      }
    }
    // Sla de categorie-filter op voor de huidige route en herteken de interface.
    function setCatFilter(o){
      const r = (typeof route !== 'undefined' && route) ? route : 'kalender';
      localStorage.setItem('planner.cats.' + r, JSON.stringify(o));
      render();
    }
    // Controleer of een categorie is ingeschakeld in de filter voor de huidige route.
    function catEnabled(cat){
      const s = getCatFilter();
      if(Object.keys(s).length === 0) return true;
      return !!s[cat];
    }

    // ===== notificaties instellingen =====
    function getNotificationsEnabled(){
      try{ return JSON.parse(localStorage.getItem('planner.notificationsEnabled')||'true'); }catch{return true;}
    }
    function setNotificationsEnabled(v){
      localStorage.setItem('planner.notificationsEnabled', JSON.stringify(!!v));
      // als meldingen worden ingeschakeld, vraag eventueel toestemming
      if(v){ setupNotifications(); scheduleDueTasks(); }
    }

    // ===== high score helpers =====
    // Haal de hoogste score op voor een spel uit localStorage. Als er nog geen score is opgeslagen, geef 0 terug.
    function getHighScore(game){
      try{
        const data = JSON.parse(localStorage.getItem('planner.highscores') || '{}');
        return data && typeof data[game] === 'number' ? data[game] : 0;
      }catch{
        return 0;
      }
    }
    // Stel een nieuwe hoogste score in voor een spel en bewaar deze in localStorage.
    function setHighScore(game, score){
      try{
        let data;
        try{ data = JSON.parse(localStorage.getItem('planner.highscores') || '{}'); }catch{ data = {}; }
        if(!data || typeof data !== 'object') data = {};
        data[game] = score;
        localStorage.setItem('planner.highscores', JSON.stringify(data));
      }catch{}
    }

    // ===== vertalingen / translations =====
    // Ondersteunde talen: Nederlands (nl), Engels (en), Frans (fr), Duits (de), Spaans (es)
    const TRANSLATIONS = {
      nl: {
        kalender:'Kalender', huiswerk:'Huiswerk', toetsen:'Toetsen', leren:'Leren', rooster:'Rooster', extra:'Extra', agenda:'Agenda', cijfers:'Cijfers', relax:'Relax', achtergrond:'Achtergrond', instellingen:'Instellingen', vertaal:'Vertaal',
        verbergAf:'verberg afgevinkte', toonFilters:'Toon filters', verbergFilters:'Verberg filters', alles:'Alles', niets:'Niets', meldingen:'Notificaties', meldingenToggle:'Meldingen aan/uit', inloggen:'Inloggen', uitloggen:'Uitloggen',
        backupOpslaan:'Back-up opslaan', backupLaden:'Back-up laden', csvExport:'Exporteren (CSV)', jsonExport:'Exporteren (JSON)', jsonImport:'Importeren (JSON)',
        gewensteGem:'Gewenst gemiddelde', wegingVolgende:'Weging komende cijfer', bereken:'Bereken', vak:'Vak', alleVakken:'Alle vakken', tetris:'Tetris', snake:'Snake', flappy:'Flappy Bird', pong:'Ping Pong', score:'Score',
        jij:'Jij', cpu:'CPU',
        // namen van extra spelletjes
        memory:'Memory', _2048:'2048', ticTacToe:'Tic-Tac-Toe', minesweeper:'Mijnenveger',
        Dag:'Dag'
        , rockPaperScissors:'Steen-Papier-Schaar', whackMole:'Mep de muis'
        , guessNumber:'Getal raden', hangman:'Galgje'
        , simon:'Volg de kleur'
        , rulesSimon:'Herhaal de kleurvolgorde door op dezelfde knoppen te klikken. De reeks wordt elke ronde langer.'
        , rulesSnake:'Gebruik de pijltjestoetsen om de slang te bewegen. Eet het voedsel en vermijd de randen en je eigen lichaam.',
        rulesFlappy:'Klik of druk op spatie om de vogel omhoog te laten vliegen. Vlieg tussen de pijpen door zonder ze te raken.',
        rulesPong:'Gebruik de linker- en rechterpijltjestoets om je peddel te bewegen. Laat de bal niet langs je peddel gaan. Wie als eerste drie punten heeft wint.',
        rulesTetris:'Draai en verplaats de blokken om volledige rijen te vullen. Gebruik pijltjestoetsen om te bewegen, omhoog om te draaien en spatie voor een snelle drop.',
        rulesMemory:'Zoek paren door twee kaarten om te draaien. Het aantal rondes telt hoe vaak je twee kaarten kiest.',
        rules2048:'Gebruik de pijltjestoetsen om tegels te verschuiven en te combineren. Bereik de tegel 2048 om te winnen.',
        rulesTicTacToe:'Zet om de beurt een kruisje of cirkel op het 3√ó3 bord. Maak als eerste drie op een rij.',
        rulesMinesweeper:'Klik op een veld om het te onthullen. Getallen geven aan hoeveel bommen rond dat vak liggen. Gebruik de rechtermuisknop om een mogelijke bom te markeren met een vlag. Het doel is om alle lege vakjes te onthullen zonder een bom te raken.',
        rulesRPS:'Kies steen, papier of schaar. Pieter kiest willekeurig. Steen verslaat schaar, schaar verslaat papier, papier verslaat steen.',
        rulesWhack:'Klik op de muis zodra hij verschijnt. Sla hem zo vaak mogelijk.',
        rulesGuess:'Raad het geheime getal tussen 1 en 100 in zo weinig mogelijk beurten.',
        rulesHangman:'Raad het geheime woord door letters te kiezen. Je hebt 6 fouten; daarna verlies je.'
        , donker:'Donker', licht:'Licht', kleur:'Kleur', achtergrondHint:'Kies een licht of donker thema, of kies zelf een kleur.'
        , higher:'Hoger!', lower:'Lager!', guessedNumber:'Je hebt het getal geraden in {n} beurten! Klik op Herstart om opnieuw te spelen.', restart:'Herstart'
        , youWin:'Je wint!', wrongGuess:'Fout!', loseWord:'Je verliest! Het woord was {word}'
        , gameOver:'Je bent af!'
        , wins:'Winsten', highLabel:'Record', rpsTie:'Gelijkspel!', rpsYouWin:'Je wint!', rpsCpuWins:'Pieter wint!'
        , markModeOn:'Markeer modus: aan', markModeOff:'Markeer modus: uit'
        , roundsLabel:'Rondes', attemptsLabel:'Beurten', memoryCongrats:'Gefeliciteerd! Je hebt alle paren gevonden!'
        , nothing:'Nog niets'
        , language:'Taal'
        , gradeCalculator:'Cijfercalculator'
        , localStorageNote:'Alle taken, cijfers en instellingen worden lokaal op deze computer opgeslagen. U hoeft niet in te loggen.'
        , voiceLabel:'Voorleesstem'
        , add:'toevoegen'
, prev:'Vorige', next:'Volgende', today:'Vandaag', month:'Maand', week:'Week', day:'Dag', newTask:'+ Taak'
        , notities:'Notities'
      },
      en: {
        kalender:'Calendar', huiswerk:'Homework', toetsen:'Tests', leren:'Study', rooster:'Schedule', extra:'Extra', agenda:'Agenda', cijfers:'Grades', relax:'Relax', achtergrond:'Background', instellingen:'Settings', vertaal:'Translate',
        verbergAf:'hide done', toonFilters:'Show filters', verbergFilters:'Hide filters', alles:'All', niets:'None', meldingen:'Notifications', meldingenToggle:'Enable notifications', inloggen:'Login', uitloggen:'Logout',
        backupOpslaan:'Save backup', backupLaden:'Load backup', csvExport:'Export (CSV)', jsonExport:'Export (JSON)', jsonImport:'Import (JSON)',
        gewensteGem:'Desired average', wegingVolgende:'Weight next grade', bereken:'Calculate', vak:'Subject', alleVakken:'All subjects', tetris:'Tetris', snake:'Snake', flappy:'Flappy Bird', pong:'Ping Pong', score:'Score',
        jij:'You', cpu:'CPU',
        memory:'Memory', _2048:'2048', ticTacToe:'Tic-Tac-Toe', minesweeper:'Minesweeper',
        Dag:'Day'
        , rockPaperScissors:'Rock Paper Scissors', whackMole:'Whack the Mouse'
        , guessNumber:'Guess Number', hangman:'Hangman'
        , simon:'Simon'
        , rulesSimon:'Repeat the colour sequence by clicking the same buttons. The sequence gets longer each round.'
        , rulesSnake:'Use the arrow keys to move the snake. Eat the food and avoid the walls and yourself.',
        rulesFlappy:'Click or press space to make the bird fly up. Fly through the pipes without hitting them.',
        rulesPong:'Use the left and right arrow keys to move your paddle. Don‚Äôt let the ball past you. First to three points wins.',
        rulesTetris:'Rotate and move the blocks to fill complete rows. Use arrow keys to move, up to rotate and space for a hard drop.',
        rulesMemory:'Find pairs by turning over two cards. The number of rounds counts how many times you pick two cards.',
        rules2048:'Use the arrow keys to slide and combine tiles. Reach the 2048 tile to win.',
        rulesTicTacToe:'Take turns placing a cross or circle on the 3√ó3 board. Make three in a row to win.',
        rulesMinesweeper:'Click a tile to uncover it. Numbers indicate how many mines are adjacent. Use right-click to flag a potential mine. Uncover all non-mine tiles without hitting a mine.',
        rulesRPS:'Choose rock, paper or scissors. Pieter chooses at random. Rock beats scissors, scissors beats paper, paper beats rock.',
        rulesWhack:'Click the mouse as soon as it appears. Hit it as many times as possible.',
        rulesGuess:'Guess the secret number between 1 and 100 in as few turns as possible.',
        rulesHangman:'Guess the secret word by choosing letters. You have 6 mistakes; afterwards you lose.'
        , donker:'Dark', licht:'Light', kleur:'Color', achtergrondHint:'Choose a light or dark theme, or pick your own color.'
        , higher:'Higher!', lower:'Lower!', guessedNumber:'You guessed the number in {n} turns! Click Restart to play again.', restart:'Restart'
        , youWin:'You win!', wrongGuess:'Wrong!', loseWord:'You lose! The word was {word}'
        , gameOver:'Game over!'
        , wins:'Wins', highLabel:'High', rpsTie:'Tie!', rpsYouWin:'You win!', rpsCpuWins:'Computer wins!'
        , markModeOn:'Mark mode: on', markModeOff:'Mark mode: off'
        , roundsLabel:'Rounds', attemptsLabel:'Turns', memoryCongrats:'Congratulations! You found all the pairs!'
        , nothing:'Nothing yet'
        , language:'Language'
        , gradeCalculator:'Grade calculator'
        , localStorageNote:'All tasks, grades and settings are stored locally on this computer. No login is required.'
        , voiceLabel:'Narrator voice'
        , add:'add'
, prev:'Previous', next:'Next', today:'Today', month:'Month', week:'Week', day:'Day', newTask:'+ Task'
        , notities:'Notes'
      },
      fr: {
        kalender:'Calendrier', huiswerk:'Devoirs', toetsen:'Tests', leren:'√âtudier', rooster:'Emploi du temps', extra:'Extra', agenda:'Agenda', cijfers:'Notes', relax:'Relax', achtergrond:'Arri√®re-plan', instellingen:'Param√®tres', vertaal:'Traduire',
        verbergAf:'cacher coch√©s', toonFilters:'Afficher filtres', verbergFilters:'Masquer filtres', alles:'Tout', niets:'Rien', meldingen:'Notifications', meldingenToggle:'Activer notifications', inloggen:'Connexion', uitloggen:'D√©connexion',
        backupOpslaan:'Sauvegarder', backupLaden:'Charger sauvegarde', csvExport:'Exporter (CSV)', jsonExport:'Exporter (JSON)', jsonImport:'Importer (JSON)',
        gewensteGem:'Moyenne souhait√©e', wegingVolgende:'Pond√©ration prochaine note', bereken:'Calculer', vak:'Mati√®re', alleVakken:'Toutes les mati√®res', tetris:'Tetris', snake:'Serpent', flappy:'Flappy Bird', pong:'Ping Pong', score:'Score',
        jij:'Vous', cpu:'Ordinateur',
        memory:'M√©moire', _2048:'2048', ticTacToe:'Morpion', minesweeper:'D√©mineur',
        Dag:'Jour'
        , rockPaperScissors:'Pierre-Feuille-Ciseaux', whackMole:'Tape la souris'
        , guessNumber:'Devine le nombre', hangman:'Pendu'
        , simon:'Simon'
        , rulesSimon:'R√©p√©tez la s√©quence de couleurs en cliquant sur les m√™mes boutons. La s√©quence s‚Äôallonge √† chaque tour.'
        , rulesSnake:"Utilisez les fl√®ches pour d√©placer le serpent. Mangez la nourriture et √©vitez les murs et votre corps.",
        rulesFlappy:"Cliquez ou appuyez sur espace pour faire voler l‚Äôoiseau vers le haut. Volez entre les tuyaux sans les toucher.",
        rulesPong:"Utilisez les fl√®ches gauche et droite pour d√©placer votre raquette. Ne laissez pas passer la balle. Le premier √† trois points gagne.",
        rulesTetris:"Faites pivoter et d√©placer les blocs pour remplir des rang√©es compl√®tes. Utilisez les fl√®ches pour bouger, haut pour pivoter et espace pour une chute rapide.",
        rulesMemory:"Trouvez des paires en retournant deux cartes. Le nombre de tours compte le nombre de fois que vous choisissez deux cartes.",
        rules2048:"Utilisez les fl√®ches pour glisser et combiner les tuiles. Atteignez la tuile 2048 pour gagner.",
        rulesTicTacToe:"Placez √† tour de r√¥le une croix ou un cercle sur le plateau 3√ó3. Faites une ligne de trois pour gagner.",
        rulesMinesweeper:"Cliquez sur une case pour la r√©v√©ler. Les chiffres indiquent le nombre de mines adjacentes. Utilisez le clic droit pour marquer une mine potentielle avec un drapeau. R√©v√©lez toutes les cases sans mines sans toucher une mine.",
        rulesRPS:"Choisissez pierre, feuille ou ciseaux. Pieter choisit au hasard. La pierre bat les ciseaux, les ciseaux battent le papier, le papier bat la pierre.",
        rulesWhack:"Cliquez sur la souris d√®s qu‚Äôelle appara√Æt. Frappez-la autant de fois que possible.",
        rulesGuess:"Devinez le nombre secret entre 1 et 100 en aussi peu de tours que possible.",
        rulesHangman:"Devinez le mot secret en choisissant des lettres. Vous avez 6 erreurs; apr√®s vous perdez."
        , donker:'Sombre', licht:'Clair', kleur:'Couleur', achtergrondHint:'Choisissez un th√®me clair ou sombre, ou choisissez votre propre couleur.'
        , higher:'Plus haut!', lower:'Plus bas!', guessedNumber:'Vous avez devin√© le nombre en {n} tours ! Cliquez sur Red√©marrer pour rejouer.', restart:'Red√©marrer'
        , youWin:'Vous gagnez!', wrongGuess:'Faux!', loseWord:'Vous perdez! Le mot √©tait {word}'
        , gameOver:'Fin du jeu!'
        , wins:'Victoires', highLabel:'Record', rpsTie:'√âgalit√©¬†!', rpsYouWin:'Vous gagnez!', rpsCpuWins:"L'ordinateur gagne!"
        , markModeOn:'Mode marquage¬†: actif', markModeOff:'Mode marquage¬†: inactif'
        , roundsLabel:'Tours', attemptsLabel:'Essais', memoryCongrats:'F√©licitations¬†! Vous avez trouv√© toutes les paires¬†!'
        , nothing:'Rien pour le moment'
        , language:'Langue'
        , gradeCalculator:'Calculateur de notes'
        , localStorageNote:'Toutes les t√¢ches, notes et param√®tres sont stock√©s localement sur cet ordinateur. Aucune connexion requise.'
        , voiceLabel:'Voix de lecture'
        , add:'ajouter'
, prev:'Pr√©c.', next:'Suiv.', today:'Aujourd\'hui', month:'Mois', week:'Semaine', day:'Jour', newTask:'+ T√¢che'
        , notities:'Notes'
      },
      de: {
        kalender:'Kalender', huiswerk:'Hausaufgaben', toetsen:'Tests', leren:'Lernen', rooster:'Stundenplan', extra:'Extra', agenda:'Agenda', cijfers:'Noten', relax:'Entspannen', achtergrond:'Hintergrund', instellingen:'Einstellungen', vertaal:'√úbersetzen',
        verbergAf:'abgehakte verbergen', toonFilters:'Filter anzeigen', verbergFilters:'Filter ausblenden', alles:'Alle', niets:'Keine', meldingen:'Benachrichtigungen', meldingenToggle:'Benachrichtigungen aktivieren', inloggen:'Anmelden', uitloggen:'Abmelden',
        backupOpslaan:'Backup speichern', backupLaden:'Backup laden', csvExport:'Exportieren (CSV)', jsonExport:'Exportieren (JSON)', jsonImport:'Importieren (JSON)',
        gewensteGem:'Gew√ºnschter Durchschnitt', wegingVolgende:'Gewichtung n√§chster Note', bereken:'Berechnen', vak:'Fach', alleVakken:'Alle F√§cher', tetris:'Tetris', snake:'Snake', flappy:'Flappy Bird', pong:'Ping Pong', score:'Punkte',
        jij:'Du', cpu:'CPU',
        memory:'Memory', _2048:'2048', ticTacToe:'Tic-Tac-Toe', minesweeper:'Minenfeld',
        Dag:'Tag'
        , rockPaperScissors:'Schere-Stein-Papier', whackMole:'Schlag die Maus'
        , guessNumber:'Zahl raten', hangman:'Galgenm√§nnchen'
        , simon:'Simon'
        , rulesSimon:'Wiederhole die Farbfolge, indem du dieselben Kn√∂pfe anklickst. Die Sequenz wird in jeder Runde l√§nger.'
        , rulesSnake:"Verwende die Pfeiltasten, um die Schlange zu bewegen. Iss das Futter und vermeide W√§nde und dich selbst.",
        rulesFlappy:"Klicke oder dr√ºcke die Leertaste, um den Vogel nach oben fliegen zu lassen. Fliege zwischen den R√∂hren hindurch, ohne sie zu ber√ºhren.",
        rulesPong:"Verwende die Pfeiltasten links und rechts, um deinen Schl√§ger zu bewegen. Lass den Ball nicht an dir vorbeigehen. Wer zuerst drei Punkte hat, gewinnt.",
        rulesTetris:"Drehe und bewege die Bl√∂cke, um vollst√§ndige Reihen zu f√ºllen. Verwende die Pfeiltasten zum Bewegen, oben zum Drehen und Leertaste f√ºr einen schnellen Fall.",
        rulesMemory:"Finde Paare, indem du zwei Karten aufdeckst. Die Anzahl der Runden z√§hlt, wie oft du zwei Karten w√§hlst.",
        rules2048:"Verwende die Pfeiltasten, um Kacheln zu verschieben und zu kombinieren. Erreiche die 2048-Kachel, um zu gewinnen.",
        rulesTicTacToe:"Setzt abwechselnd ein Kreuz oder einen Kreis auf das 3√ó3-Feld. Mache zuerst drei in einer Reihe.",
        rulesMinesweeper:"Klicke auf ein Feld, um es aufzudecken. Zahlen zeigen an, wie viele Minen benachbart sind. Verwende einen Rechtsklick, um eine m√∂gliche Mine mit einer Flagge zu markieren. Decke alle nicht-minen Felder auf, ohne eine Mine zu treffen.",
        rulesRPS:"W√§hle Stein, Papier oder Schere. Pieter w√§hlt zuf√§llig. Stein schl√§gt Schere, Schere schl√§gt Papier, Papier schl√§gt Stein.",
        rulesWhack:"Klicke auf die Maus, sobald sie erscheint. Triff sie so oft wie m√∂glich.",
        rulesGuess:"Rate die geheime Zahl zwischen 1 und 100 mit m√∂glichst wenigen Versuchen.",
        rulesHangman:"Rate das geheime Wort, indem du Buchstaben ausw√§hlst. Du hast 6 Fehler; danach verlierst du."
        , donker:'Dunkel', licht:'Hell', kleur:'Farbe', achtergrondHint:'W√§hle ein helles oder dunkles Thema oder w√§hle deine eigene Farbe.'
        , higher:'H√∂her!', lower:'Tiefer!', guessedNumber:'Du hast die Zahl in {n} Versuchen erraten! Klicke auf Neustart, um erneut zu spielen.', restart:'Neustart'
        , youWin:'Du gewinnst!', wrongGuess:'Falsch!', loseWord:'Du verlierst! Das Wort war {word}'
        , gameOver:'Spiel vorbei!'
        , wins:'Gewinne', highLabel:'Best', rpsTie:'Unentschieden!', rpsYouWin:'Du gewinnst!', rpsCpuWins:'Der Computer gewinnt!'
        , markModeOn:'Markiermodus: ein', markModeOff:'Markiermodus: aus'
        , roundsLabel:'Runden', attemptsLabel:'Versuche', memoryCongrats:'Gl√ºckwunsch! Du hast alle Paare gefunden!'
        , nothing:'Noch nichts'
        , language:'Sprache'
        , gradeCalculator:'Notenrechner'
        , localStorageNote:'Alle Aufgaben, Noten und Einstellungen werden lokal auf diesem Computer gespeichert. Keine Anmeldung erforderlich.'
        , voiceLabel:'Vorlesestimme'
        , add:'hinzuf√ºgen'
, prev:'Zur√ºck', next:'Weiter', today:'Heute', month:'Monat', week:'Woche', day:'Tag', newTask:'+ Aufgabe'
        , notities:'Notizen'
      },
      es: {
        kalender:'Calendario', huiswerk:'Deberes', toetsen:'Ex√°menes', leren:'Estudiar', rooster:'Horario', extra:'Extra', agenda:'Agenda', cijfers:'Notas', relax:'Rel√°jate', achtergrond:'Fondo', instellingen:'Ajustes', vertaal:'Traducir',
        verbergAf:'ocultar marcadas', toonFilters:'Mostrar filtros', verbergFilters:'Ocultar filtros', alles:'Todo', niets:'Nada', meldingen:'Notificaciones', meldingenToggle:'Activar notificaciones', inloggen:'Iniciar sesi√≥n', uitloggen:'Cerrar sesi√≥n',
        backupOpslaan:'Guardar copia', backupLaden:'Cargar copia', csvExport:'Exportar (CSV)', jsonExport:'Exportar (JSON)', jsonImport:'Importar (JSON)',
        gewensteGem:'Promedio deseado', wegingVolgende:'Peso siguiente nota', bereken:'Calcular', vak:'Asignatura', alleVakken:'Todas las asignaturas', tetris:'Tetris', snake:'Serpiente', flappy:'Flappy Bird', pong:'Ping Pong', score:'Puntuaci√≥n',
        jij:'T√∫', cpu:'CPU',
        memory:'Memoria', _2048:'2048', ticTacToe:'Tres en raya', minesweeper:'Buscaminas',
        Dag:'D√≠a'
        , rockPaperScissors:'Piedra-Papel-Tijeras', whackMole:'Golpea al rat√≥n'
        , guessNumber:'Adivina el n√∫mero', hangman:'Ahorcado'
        , simon:'Sim√≥n'
        , rulesSimon:'Repite la secuencia de colores haciendo clic en los mismos botones. La secuencia se hace m√°s larga cada ronda.'
        , rulesSnake:"Usa las flechas para mover la serpiente. Come la comida y evita las paredes y tu propio cuerpo.",
        rulesFlappy:"Haz clic o presiona espacio para que el p√°jaro vuele hacia arriba. Vuela entre los tubos sin tocarlos.",
        rulesPong:"Usa las flechas izquierda y derecha para mover tu paleta. No dejes que la pelota pase de ti. El primero en obtener tres puntos gana.",
        rulesTetris:"Gira y mueve los bloques para completar filas. Usa las flechas para mover, arriba para girar y espacio para una ca√≠da r√°pida.",
        rulesMemory:"Encuentra pares girando dos cartas. El n√∫mero de rondas cuenta cu√°ntas veces eliges dos cartas.",
        rules2048:"Usa las flechas para deslizar y combinar fichas. Llega a la ficha 2048 para ganar.",
        rulesTicTacToe:"Toma turnos colocando una X o un O en el tablero de 3√ó3. Haz tres en l√≠nea para ganar.",
        rulesMinesweeper:"Haz clic en una casilla para revelarla. Los n√∫meros indican cu√°ntas minas hay cerca. Usa el bot√≥n derecho para marcar una mina potencial con una bandera. Descubre todas las casillas sin minas sin tocar una mina.",
        rulesRPS:"Elige piedra, papel o tijeras. Pieter elige al azar. La piedra vence a las tijeras, las tijeras vencen al papel y el papel vence a la piedra.",
        rulesWhack:"Haz clic en el rat√≥n tan pronto como aparezca. Golp√©alo tantas veces como sea posible.",
        rulesGuess:"Adivina el n√∫mero secreto entre 1 y 100 con el menor n√∫mero de intentos.",
        rulesHangman:"Adivina la palabra secreta eligiendo letras. Tienes 6 errores; despu√©s pierdes."
        , donker:'Oscuro', licht:'Claro', kleur:'Color', achtergrondHint:'Elige un tema claro u oscuro, o selecciona tu propio color.'
        , higher:'M√°s alto!', lower:'M√°s bajo!', guessedNumber:'Has adivinado el n√∫mero en {n} intentos. Pulsa Reiniciar para jugar de nuevo.', restart:'Reiniciar'
        , youWin:'¬°Ganaste!', wrongGuess:'¬°Fallaste!', loseWord:'Has perdido. La palabra era {word}'
        , gameOver:'¬°Fin del juego!'
        , wins:'Victorias', highLabel:'R√©cord', rpsTie:'¬°Empate!', rpsYouWin:'¬°Ganaste!', rpsCpuWins:'¬°La CPU gana!'
        , markModeOn:'Modo marcar: encendido', markModeOff:'Modo marcar: apagado'
        , roundsLabel:'Rondas', attemptsLabel:'Intentos', memoryCongrats:'¬°Felicidades! ¬°Has encontrado todas las parejas!'
        , nothing:'A√∫n nada'
        , language:'Idioma'
        , gradeCalculator:'Calculadora de notas'
        , localStorageNote:'Todas las tareas, notas y ajustes se guardan localmente en este ordenador. No es necesario iniciar sesi√≥n.'
        , voiceLabel:'Voz de lectura'
        , add:'a√±adir'
, prev:'Anterior', next:'Siguiente', today:'Hoy', month:'Mes', week:'Semana', day:'D√≠a', newTask:'+ Tarea'
        , notities:'Notas'
      }
    };
    // Ophalen huidige taal uit localStorage of standaard 'nl'
    function getLang(){ return localStorage.getItem('planner.lang') || 'nl'; }
function setLang(lang){
  localStorage.setItem('planner.lang', lang);
  render();
  // Update spelregels voor alle games zodat ze vertalen naar de nieuwe taal
  if(typeof updateRulesLanguage === 'function'){
    updateRulesLanguage();
  }
}
    function t(key){ const lang = getLang(); const d = TRANSLATIONS[lang] || TRANSLATIONS['nl']; return d[key] || key; }

    // Map internal language codes to locale strings for date formatting
    const LOCALES = { nl:'nl-NL', en:'en-US', fr:'fr-FR', de:'de-DE', es:'es-ES' };
    function getLocale(){ const lang = getLang(); return LOCALES[lang] || 'nl-NL'; }

    // Algemene vertaalfunctie. Geeft de vertaling voor een sleutel in de opgegeven taal terug.
    // Voorbeeld: vertalen('kalender','en') geeft 'Calendar'. Als sleutel niet bestaat, wordt deze teruggegeven.
    function vertalen(key, lang){
      const d = TRANSLATIONS[lang] || TRANSLATIONS['nl'];
      return d[key] || key;
    }

    // Vertaal arbitraire tekst tussen talen op basis van interne woordenlijst.
    // Zoekt de ingevoerde tekst in de brontaal in de vertaalwoordenlijst en
    // geeft de overeenkomstige vertaling in de doeltaal terug. Als de tekst
    // niet wordt gevonden, wordt dezelfde tekst teruggegeven.
    function translateText(text, fromLang, toLang){
      try{
        if(!text) return '';
        const fromDict = TRANSLATIONS[fromLang] || {};
        const toDict = TRANSLATIONS[toLang] || {};
        const lower = text.trim().toLowerCase();
        let foundKey = null;
        for(const key in fromDict){
          if(Object.prototype.hasOwnProperty.call(fromDict, key)){
            const val = '' + fromDict[key];
            if(val.trim().toLowerCase() === lower){
              foundKey = key;
              break;
            }
          }
        }
        if(foundKey){
          return toDict[foundKey] || text;
        }
        return text;
      }catch{
        return text;
      }
    }

    // Voice selection helpers
    function populateVoices(){
      const sel = document.getElementById('voiceSelect');
      if(!sel) return;
      // Fetch available voices from the speech synthesis API
      let voices = speechSynthesis.getVoices();
      if(!voices || voices.length === 0){
        // on some browsers voices may not be loaded yet
        speechSynthesis.onvoiceschanged = () => populateVoices();
        return;
      }
      const current = localStorage.getItem('planner.voice') || '';
      sel.innerHTML = '';
      voices.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.voiceURI;
        opt.textContent = v.name + ' (' + v.lang + ')';
        if(v.voiceURI === current){ opt.selected = true; }
        sel.appendChild(opt);
      });
      sel.onchange = function(){ localStorage.setItem('planner.voice', this.value || ''); };
    }

    // Update game rule texts to the currently selected language. This will find any
    // element with a data-rule-key attribute and replace its textContent with the
    // translated string for that key. This ensures that speluitleg meevertaalt.
    function updateRulesLanguage(){
      const langEls = document.querySelectorAll('[data-rule-key]');
      langEls.forEach(el => {
        const key = el.dataset.ruleKey;
        if(key) el.textContent = t(key);
      });
    }
    // Wissel de geselecteerde talen in de vertaalinterface.
    function swapTransLangs(){
      const fromSel = document.getElementById('transLangFrom');
      const toSel = document.getElementById('transLangTo');
      if(fromSel && toSel){
        const tmp = fromSel.value;
        fromSel.value = toSel.value;
        toSel.value = tmp;
      }
    }

    // Wijzig de taal via de taalselectie in de instellingen
    function changeLanguage(lang){
      setLang(lang);
    }

    // Werk de labels van het zijmenu bij op basis van de geselecteerde taal.
    function updateNavLabels(){
      const icons = {
        kalender:'üìÖ', huiswerk:'üìÑ', toetsen:'üìù', leren:'üìñ', rooster:'üìö', extra:'üß©', agenda:'üìÜ', cijfers:'üìä', relax:'üéÆ', achtergrond:'üñºÔ∏è', instellingen:'‚öôÔ∏è', notities:'üìî'
      };
      const links = document.querySelectorAll('#menu a');
      links.forEach(a => {
        const routeKey = a.dataset.route;
        if(routeKey && icons[routeKey]){
          a.textContent = icons[routeKey] + ' ' + t(routeKey);
        }
      });
    }

    function toolbar(mode='full', extraRight=''){
      // Build a cleaner toolbar. Always show the "verberg afgevinkte" checkbox and a toggle button to show/hide filters.
      const hideCtrl = `<label class='chk'><input type='checkbox' ${getHide()?"checked":""} onchange='setHide(this.checked)'>${t('verbergAf')}</label>`;
      if(mode === 'none') return '';
      // If hide-only mode (used on lists without filters), return hide checkbox and any extra controls aligned to the right.
      if(mode === 'hide') {
        // Alleen de verberg-afgevinkte checkbox en extra knoppen aan de rechterkant tonen
        return `<div class='toolbar'><span style='display:flex;align-items:center;gap:4px;margin-right:8px'>${hideCtrl}</span><span style='flex:1'></span>${extraRight}</div>`;
      }
      // Category chips to filter by type
      const chips = CATS.map(c=>`<label class='chk'><input type='checkbox' ${catEnabled(c)?'checked':''} onchange='toggleCat("${c}",this.checked)'>${c}</label>`).join(' ');
      // Knop om filters te tonen of te verbergen. Gebruik vertalingen.
      const toggleBtn = `<button class='btn' onclick='toggleFilters()'>${filtersExpanded ? t('verbergFilters') : t('toonFilters')}</button>`;
      // Compose toolbar contents
      // Top row: verberg checkbox links, toggle filters knop (en evt extra knoppen) rechts.
      let bottomRow = '';
      if(filtersExpanded){
        // wanneer filters zichtbaar zijn: categorie chips en 'alles/niets' op aparte regel
        bottomRow += `<span style='display:flex;flex-wrap:wrap;gap:4px;margin-right:8px'>${chips}</span>`;
        bottomRow += `<button class='btn' onclick='enableAllCats()'>${t('alles')}</button>`;
        bottomRow += `<button class='btn' style='margin-left:4px' onclick='disableAllCats()'>${t('niets')}</button>`;
      }
      // Top row uses justify-content to push toggle/extra to the right
      let html = `<div style='display:flex;align-items:center;justify-content:space-between;gap:4px'>`
        + `<span style='display:flex;align-items:center;gap:4px'>${hideCtrl}</span>`
        + `<span style='display:flex;align-items:center;gap:4px'>${toggleBtn}${extraRight ? `<span style='margin-left:8px'>${extraRight}</span>` : ''}</span>`
        + `</div>`;
      if(bottomRow){
        html += `<div style='display:flex;align-items:center;flex-wrap:wrap;gap:4px;margin-top:4px'>${bottomRow}</div>`;
      }
      return `<div class='toolbar'>${html}</div>`;
    }

    // toggle filters visibility
    function toggleFilters(){
      filtersExpanded = !filtersExpanded;
      render();
    }
    function toggleCat(cat,val){const s=getCatFilter();s[cat]=!!val;setCatFilter(s)}
    function enableAllCats(){const s={};CATS.forEach(c=>s[c]=true);setCatFilter(s)}
    function disableAllCats(){const s={};CATS.forEach(c=>s[c]=false);setCatFilter(s)}
    function empty(){return `<div style='color:#94a3b8'>Nog niets</div>`}
    // repetition
function occursOn(t,dayISO){
const start=t.date;
// Als de taak geen startdatum heeft kan deze niet voorkomen op deze dag
if(!start) return false;
// Indien de taak een lijst van overgeslagen datums heeft, en deze datum daarin voorkomt, geef dan false.
if(Array.isArray(t.skipDates) && t.skipDates.includes(dayISO)) return false;
// Als de taak een einddatum heeft, beschouw het als een multi-daagse taak
if(t.endDate && t.endDate!==''){
  // Vergelijk ISO-strings lexicografisch: werkt omdat formaat YYYY-MM-DD is
  if(dayISO >= start && dayISO <= t.endDate){
    return true;
  }
}
if(dayISO===start)return true;
const rep=t.repeat||'none';if(rep==='none')return false;const d0=new Date(start),d1=new Date(dayISO);const diff=Math.floor((d1-d0)/86400000);if(diff<0)return false;switch(rep){case 'daily':return true;case '2d':return diff%2===0;case '3d':return diff%3===0;case 'weekly':return diff%7===0;case '2w':return diff%14===0;case '3w':return diff%21===0;case 'monthly':return d1.getDate()===d0.getDate();case '2m':{const m=(d1.getFullYear()-d0.getFullYear())*12+(d1.getMonth()-d0.getMonth());return d1.getDate()===d0.getDate()&&m>=0&&m%2===0}case '3m':{const m=(d1.getFullYear()-d0.getFullYear())*12+(d1.getMonth()-d0.getMonth());return d1.getDate()===d0.getDate()&&m>=0&&m%3===0}case 'yearly':return d1.getDate()===d0.getDate()&&d1.getMonth()===d0.getMonth()}return false}
    // routing
    function render(){
      // update menu labels based on selected language
      updateNavLabels();
      const c=el('content'); c.innerHTML='';
      // update title based on route (use translation if possible)
      const titleKey = route === 'kalender' ? (view === 'day' ? 'Dag' : 'Kalender') : route;
      el('title').innerText = t(titleKey) || titleKey;
      // Reset de subdatum wanneer we niet op de kalenderpagina zijn zodat de datum niet meebeweegt met de ref-datum
      if(route !== 'kalender'){
        const subEl = el('sub');
        if(subEl) subEl.innerText = '';
      }
      // Toon of verberg kalenderknoppen in de header afhankelijk van de huidige pagina.
      const hc = el('headerControls');
      if(hc) hc.style.display = (route === 'kalender' ? '' : 'none');
      if(route==='kalender'){
        // Update header control labels based on the current language
        const prevBtn = el('prev');
        const nextBtn = el('next');
        const todayBtn = el('today');
        const monthBtn = document.querySelector("button[data-v='month']");
        const weekBtn  = document.querySelector("button[data-v='week']");
        const dayBtn   = document.querySelector("button[data-v='day']");
        const newBtn   = el('new');
        if(prevBtn) prevBtn.title = t('prev');
        if(nextBtn) nextBtn.title = t('next');
        if(todayBtn) todayBtn.textContent = t('today');
        if(monthBtn) monthBtn.textContent = t('month');
        if(weekBtn) weekBtn.textContent  = t('week');
        if(dayBtn) dayBtn.textContent    = t('day');
        if(newBtn) newBtn.textContent    = t('newTask');
        if(view==='month') renderMonth(); else if(view==='week') renderWeek(); else renderDay(ref);
        return;
      }
      if(route==='relax'){
        // Relax: kies een spel en speel het in de gameArea
        const buttons = [
          { id: 'snake', label: 'üêç ' + t('snake') },
          { id: 'flappy', label: 'üïäÔ∏è ' + t('flappy') },
          { id: 'pong', label: 'üèì ' + t('pong') },
          { id: 'tetris', label: 'üî∑ ' + t('tetris') },
          { id: 'memory', label: 'üß† ' + t('memory') },
          { id: '2048', label: 'üî¢ ' + t('_2048') },
          { id: 'tictactoe', label: '‚ùå‚≠ï ' + t('ticTacToe') },
          { id: 'minesweeper', label: 'üí£ ' + t('minesweeper') },
          { id: 'rps', label: '‚úä‚úã‚úåÔ∏è ' + t('rockPaperScissors') },
          { id: 'whack', label: 'üê≠ ' + t('whackMole') },
          { id: 'guess', label: 'üéØ ' + t('guessNumber') },
          { id: 'hangman', label: 'ü™¢ ' + t('hangman') },
          { id: 'simon', label: 'üî∫ ' + t('simon') }
        ].map(g => `<button class='btn' onclick="selectGame('${g.id}')">${g.label}</button>`).join('');
        c.innerHTML = `<h3>${t('relax')}</h3><div style='display:flex;gap:6px;flex-wrap:wrap;margin:6px 0'>${buttons}</div><div id='gameArea' style='background:#0b1220;border:1px solid var(--b);border-radius:8px;min-height:420px;padding:8px'></div>`;
        return;
      }
      if(route==='agenda'){
        // Agenda: toon taken voor geselecteerde dag met datumkeuzer
        const dayISO = iso(ref);
        const base=(getHide()?tasks.filter(t=>!t.done):tasks).filter(t=>catEnabled(t.category||'anders'));
        const its = base.filter(t=>t.date===dayISO || occursOn(t, dayISO)).sort((a,b)=>(a.start||'99:99').localeCompare(b.start||'99:99'));
        const right = `<button class='btn' onclick='setAgendaToday()'>Vandaag</button>`;
        const dateInput = `<input type='date' id='agDate' value='${dayISO}' onchange='setAgendaDate(this.value)' style='width:auto'>`;
        // zoekveld met vergrootglas
        // In agenda is geen zoekveld meer; alleen datumselectie tonen
        c.innerHTML = toolbar('hide', right) + `<div style='display:flex;gap:6px;align-items:center;margin-bottom:8px'>${dateInput}</div>` +
          (its.length ? its.map(t => renderPillHtml(t, dayISO)).join('') : empty());
        return;
      }
      if(route==='notities'){
        // Notities: beheer boeken en hoofdstukken
        loadBooks();
        // zorg dat indices geldig blijven
        if(bookIndex >= books.length) bookIndex = Math.max(0, books.length - 1);
        let html = '';
        // als we in het boekenoverzicht zijn
        if(notesView === 'library'){
          html += `<h3>Notities</h3>`;
          html += `<div style='display:flex;flex-wrap:wrap;gap:8px;margin-bottom:8px'>`;
          books.forEach((b,i)=>{
            html += `<div class='pill' style='cursor:pointer' onclick='selectBook(${i})'>${b.title || ('Boek '+(i+1))}</div>`;
          });
          html += `<button class='btn' onclick='newBook()'>+ Boek</button>`;
          html += `</div>`;
        } else {
          // lees- of bewerkmodus binnen een boek
          const currentBook = books[bookIndex] || { title:'', chapters: [] };
          // fix chapter index
          if(currentBook.chapters && currentBook.chapters.length > 0){
            if(chapterIndex >= currentBook.chapters.length) chapterIndex = currentBook.chapters.length - 1;
            if(chapterIndex < 0) chapterIndex = 0;
          } else {
            chapterIndex = 0;
          }
          const currentChapter = (currentBook.chapters && currentBook.chapters[chapterIndex]) || { title:'', text:'' };
          html += `<h3>${currentBook.title ? currentBook.title.replace(/</g,'&lt;').replace(/>/g,'&gt;') : ('Boek '+(bookIndex+1))}</h3>`;
          // bovenste knoppenbalk
          html += `<div style='display:flex;gap:6px;flex-wrap:wrap;margin-bottom:6px'>`;
          html += `<button class='btn' onclick='enterLibrary()'>üìö Terug</button>`;
          // vorige/volgende alleen indien hoofdstukken aanwezig
          html += `<button class='btn' onclick='selectChapter(${chapterIndex-1})'>‚óÄ</button>`;
          html += `<button class='btn' onclick='selectChapter(${chapterIndex+1})'>‚ñ∂</button>`;
          if(notesView === 'book'){
            // Gebruik dubbele quotes voor onclick en enkel quotes binnen de JavaScript-strings om HTML-validatie te behouden
            html += `<button class='btn' onclick="notesView='edit';render()">Bewerk</button>`;
          } else {
            html += `<button class='btn' onclick='saveChapter()'>Opslaan</button>`;
            html += `<button class='btn' onclick="notesView='book';render()">Annuleren</button>`;
            html += `<button class='btn' onclick='deleteChapter()'>Verwijder</button>`;
          }
          html += `<button class='btn' onclick='newChapter()'>+ Hoofdstuk</button>`;
          html += `<button class='btn' onclick='newBook()'>+ Boek</button>`;
          html += `</div>`;
          // inhoud of editor
          if(notesView === 'book'){
            // leesmodus: toon titel en tekst
            html += `<h4 style='margin:6px 0'>${(currentChapter.title || '').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</h4>`;
            html += `<div style='white-space:pre-wrap;min-height:200px;padding:8px;border:1px solid var(--b);border-radius:6px;background:rgba(0,0,0,0.05)'>${(currentChapter.text || '').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div>`;
          } else {
            // bewerkmodus: formulier
            html += `<input id='chapterTitle' value='${(currentChapter.title || '').replace(/"/g,'&quot;')}' placeholder='Hoofdstuk titel' style='width:100%;font-size:16px;padding:4px;margin-bottom:4px'>`;
            html += `<textarea id='chapterText' style='width:100%;height:200px;padding:6px;margin-bottom:4px'>${currentChapter.text ? currentChapter.text.replace(/</g,'&lt;').replace(/>/g,'&gt;') : ''}</textarea>`;
          }
        }
        c.innerHTML = html;
        return;
      }
      if(route==='cijfers'){
        // Cijfers: toon lijst van cijfers per vak, zonder globale gemiddelde
        let html = toolbar('none');
        html += `<div style='display:flex;gap:6px;margin:6px 0;flex-wrap:wrap'><button class='btn' onclick='newGrade()'>+ Cijfer toevoegen</button></div>`;
        if(grades.length){
          // groepeer cijfers per vak en toon per vak een gemiddelde
          const stats = {};
          grades.forEach(g=>{
            const subject = g.vak && g.vak.trim() ? g.vak.trim() : 'Overig';
            if(!stats[subject]) stats[subject] = { grades: [], totalW:0, totalS:0 };
            stats[subject].grades.push(g);
            const w = parseFloat(g.weight)||0;
            const s = parseFloat(g.score)||0;
            stats[subject].totalW += w;
            stats[subject].totalS += s*w;
          });
          Object.keys(stats).sort().forEach(subj=>{
            const st = stats[subj];
            const avgSub = st.totalW>0 ? st.totalS/st.totalW : 0;
            html += `<h4 style='margin:10px 0 4px'>${subj} (gemiddelde: ${avgSub.toFixed(2)})</h4>`;
            html += st.grades.map(renderGradePillHtml).join('');
          });
        } else {
          html += empty();
        }
        // Cijfercalculator met vakselectie
        html += `<h4 style='margin:12px 0 6px'>${t('gradeCalculator')}</h4>`;
        // Bouw opties voor vakselectie: lege optie betekent alle vakken.
        const calcOptions = [''].concat(subjects).map(v => `<option value="${v}">${v || 'Alle vakken'}</option>`).join('');
        html += `<div style='display:flex;gap:6px;flex-wrap:wrap;align-items:center;margin-bottom:12px'>
          <label style='display:flex;flex-direction:column;font-size:12px'>Vak<select id='calcSubject' style='width:120px'>${calcOptions}</select></label>
          <label style='display:flex;flex-direction:column;font-size:12px'>Gewenst gemiddelde<input id='calcDesired' type='number' step='0.1' min='0' max='10' style='width:80px'></label>
          <label style='display:flex;flex-direction:column;font-size:12px'>Weging komende cijfer<input id='calcWeight' type='number' step='0.1' min='0.1' value='1' style='width:80px'></label>
          <button class='btn' onclick='calcRequiredGrade()'>Bereken</button>
          <span id='calcResult' style='margin-left:6px;font-weight:bold'></span>
        </div>`;
        c.innerHTML = html;
        return;
      }
      if(route==='achtergrond'){
        // Achtergrondinstellingen: thema's, regenboogopties, kleuren, opaciteit en panel-transparantie
        let html = `<h3>${t('achtergrond')}</h3>`;
        html += `<div class='toolbar' style='flex-wrap:wrap'>`;
        html += `<button class='btn' onclick="setBg('dark')">${t('donker')}</button>`;
        html += `<button class='btn' onclick="setBg('light')">${t('licht')}</button>`;
        html += `<button class='btn' onclick="setBgRainbow(false)">Regenboog</button>`;
        html += `<button class='btn' onclick="setBgRainbow(true)">Pastel regenboog</button>`;
        html += `<label class='chk'>${t('kleur')} <input type='color' id='bgColor'></label>`;
        html += `</div>`;
        // aanvullende instellingen
        html += `<div style='display:flex;flex-wrap:wrap;gap:10px;margin-top:8px'>`;
        html += `<label class='chk'>Tekstkleur <input type='color' id='textColor'></label>`;
        html += `<label class='chk'>Kleur zijbalk <input type='color' id='asideColor'></label>`;
        html += `<label class='chk'>Afbeelding doorzichtigheid <input type='range' id='imgOpacity' min='0' max='100'></label>`;
        html += `<label class='chk'>Zijbalk doorzichtigheid <input type='range' id='asideOpacity' min='0' max='100'></label>`;
        html += `<label class='chk'><input type='checkbox' id='panelsToggle'> Panelen transparant</label>`;
        // toevoeging: paneelkleur en opaciteit aanpassen
        html += `<label class='chk'>Kleur panelen <input type='color' id='panelColor'></label>`;
        html += `<label class='chk'>Panelen opaciteit <input type='range' id='panelOpacity' min='0' max='100'></label>`;
        html += `</div>`;
        // upload
        html += `<div style='margin-top:8px'>`;
        html += `<label class='chk'>Afbeelding uploaden <input type='file' id='bgUpload'></label>`;
        html += `</div>`;
        html += `<small style='color:#94a3b8;display:block;margin-top:6px'>${t('achtergrondHint')}</small>`;
        // laad opgeslagen achtergronden en toon ze onder de uploadopties
        try { loadBackgrounds(); } catch {}
        html += `<h4 style='margin:12px 0 6px'>Opgeslagen achtergronden</h4>`;
        if(backgroundsList && backgroundsList.length){
          backgroundsList.forEach(bg => {
            html += `<div class='pill' style='border-color:#64748b'><span>${bg.name}</span><span>` +
            `<button class='btn' onclick='useBackground("${bg.id}")'>Gebruik</button>` +
            `<button class='btn' onclick='renameBackground("${bg.id}")'>Naam wijzigen</button>` +
            `<button class='btn' onclick='deleteBackground("${bg.id}")'>Verwijderen</button>` +
            `</span></div>`;
          });
        } else {
          html += `<p style='font-size:13px;color:#94a3b8'>Er zijn nog geen opgeslagen achtergronden.</p>`;
        }
        c.innerHTML = html;
        // init kleurkiezer voor achtergrondkleur
        const col = el('bgColor');
        if(col){ const cur = getBgColor(); col.value = cur || '#0f172a'; col.oninput = e => setBgColor(e.target.value); }
        // init tekstkleur
        const tcol = el('textColor');
        if(tcol){
          const curT = getTextColor();
          if(curT){
            tcol.value = curT;
          } else {
            try {
              const computed = getComputedStyle(document.documentElement).color;
              tcol.value = rgbToHex(computed);
            } catch {
              tcol.value = '#e5e7eb';
            }
          }
          tcol.oninput = e => setTextColor(e.target.value);
        }
        // init aside kleur
        const acol = el('asideColor');
        if(acol){
          const curA = getAsideColor();
          if(curA){
            acol.value = curA;
          } else {
            try {
              const computed = getComputedStyle(document.documentElement).getPropertyValue('--aside-bg');
              acol.value = (computed && computed.trim().startsWith('#')) ? computed.trim() : '#111827';
            } catch {
              acol.value = '#111827';
            }
          }
          acol.oninput = e => setAsideColor(e.target.value);
        }
        // init afbeelding opaciteit slider
        const op = el('imgOpacity');
        if(op){
          let ov = document.getElementById('bgOverlay');
          if(ov){
            const current = parseFloat(ov.style.opacity || '1');
            op.value = Math.round(current * 100);
          } else op.value = 100;
          op.oninput = e => setImageOpacity(e.target.value);
        }
        // init zijbalk opaciteit slider
        const ap = el('asideOpacity');
        if(ap){
          const current = getAsideOpacity();
          ap.value = Math.round((current || 1) * 100);
          ap.oninput = e => setAsideOpacity(e.target.value);
        }
        // init panel toggle
        const pt = el('panelsToggle');
        if(pt){ pt.checked = document.body.classList.contains('noPanels'); pt.onchange = e => togglePanels(e.target.checked); }
        // init paneelkleur
        const pc = el('panelColor');
        if(pc){
          // haal huidige paneelkleur op of gebruik standaard
          let current = getPanelColor();
          if(!current){
            // probeer huidige waarde van CSS-variabele te lezen
            try {
              const computed = getComputedStyle(document.documentElement).getPropertyValue('--panel-bg');
              if(computed && computed.trim()){
                // css-variabele kan rgba(...) zijn; converteer naar hex zonder alpha
                const rgbMatch = computed.trim().match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                if(rgbMatch){
                  const r = parseInt(rgbMatch[1]);
                  const g = parseInt(rgbMatch[2]);
                  const b = parseInt(rgbMatch[3]);
                  current = '#' + [r,g,b].map(x => ('0' + x.toString(16)).slice(-2)).join('');
                }
              }
            } catch {}
          }
          pc.value = current || '#0b1220';
          pc.oninput = e => setPanelColor(e.target.value);
        }
        // init paneelopaciteit
        const pop = el('panelOpacity');
        if(pop){
          const curOp = getPanelOpacity();
          pop.value = Math.round(((curOp !== undefined && curOp !== null) ? curOp : 1) * 100);
          pop.oninput = e => setPanelOpacity(e.target.value);
        }
        // upload handler
        const up = el('bgUpload');
        if(up){ up.onchange = handleBgUpload; }
        return;
      } else if(route==='instellingen'){
        // Instellingenpagina: notificaties, accountinstellingen, Firebase, back-up en takenimport/export
        // bepaal notificatie status uit storage
        const notifOn = getNotificationsEnabled();
        // Instellingenpagina bouwen (zonder login/Firebase)
        let settingsHtml = `<h3>${t('instellingen')}</h3>`;
        // Taalinstelling
        settingsHtml += `<div class='card' style='margin:0'>
          <h4 style='margin:0 0 6px'>${t('language')}</h4>
          <select id='langSelect' onchange='changeLanguage(this.value)' style='width:160px'>
            <option value='nl'>Nederlands</option>
            <option value='en'>English</option>
            <option value='fr'>Fran√ßais</option>
            <option value='de'>Deutsch</option>
            <option value='es'>Espa√±ol</option>
          </select>
        </div>`;
        // Notificaties
        settingsHtml += `<div class='card' style='margin:10px 0 0'>
          <h4 style='margin:0 0 6px'>${t('meldingen')}</h4>
          <label class='chk'><input type='checkbox' id='notifToggle' ${notifOn? 'checked':''} onchange='setNotificationsEnabled(this.checked)'> ${t('meldingenToggle')}</label>
        </div>`;
        // Voorleesstem selectie
        settingsHtml += `<div class='card' style='margin:10px 0 0'>
          <h4 style='margin:0 0 6px'>${t('voiceLabel')}</h4>
          <select id='voiceSelect' style='width:100%'></select>
        </div>`;
        // Geen inloggen of Firebase: gegevens worden lokaal opgeslagen
        settingsHtml += `<div class='card' style='margin:10px 0 0'>
          <p style='margin:0'>${t('localStorageNote')}</p>
        </div>`;
        // Vertaalfunctie is verplaatst naar aparte pagina. Er is geen vertaalsectie meer in de instellingen.
        // Plaats de inhoud
        c.innerHTML = settingsHtml;
        // stel de taalselectie in op de huidige taal
        const langSel = document.getElementById('langSelect');
        if(langSel){ langSel.value = getLang(); }
        // populate voice select
        setTimeout(populateVoices, 0);
        return;
      } else if(route==='account'){
        // Login/account pagina: toon login-formulier of huidige gebruiker
        let loginHtml = `<h3>Account</h3>`;
        let currentUser = null;
        // Bepaal ingelogde gebruiker: Firebase of lokaal
        try {
          if (typeof auth !== 'undefined' && auth && auth.currentUser) {
            currentUser = { email: auth.currentUser.email || '' };
          } else {
            currentUser = JSON.parse(localStorage.getItem('planner.localUser') || 'null');
          }
        } catch (e) {
          currentUser = null;
        }
        if (currentUser) {
          // Toon uitlog-knop; gebruik gebruikersnaam indien beschikbaar
          const name = (currentUser.username || currentUser.email || '');
          // Toon uitlog- en accountverwijderknoppen wanneer ingelogd
          loginHtml += `<div class='card' style='margin:10px 0 0'>` +
            `<p style='margin:0'>Ingelogd als ${name}</p>` +
            `<div style='display:flex;gap:6px;margin-top:6px;flex-wrap:wrap'>` +
              `<button class='btn' onclick='logoutLocal()'>Uitloggen</button>` +
              `<button class='btn' onclick='deleteLocalAccount()'>Account verwijderen</button>` +
            `</div>` +
          `</div>`;
        } else {
          // Toon loginformulier met gebruikersnaam en wachtwoord en registreerknop
          loginHtml += `<div class='card' style='margin:10px 0 0'>` +
            `<div style='display:grid;gap:6px;margin-bottom:6px'>` +
            `<label>Gebruikersnaam</label><input id='user' type='text'>` +
            `<label>Wachtwoord</label><input id='pass' type='password'>` +
            // extra veld voor wachtwoord-hint tijdens registratie; optioneel
            `<label>Tip voor wachtwoord (optioneel)</label><input id='hint' type='text' placeholder='Bijv. naam van je huisdier'>` +
            `</div>` +
            `<div style='display:flex;gap:6px;flex-wrap:wrap'>` +
            `<button class='btn' onclick='loginLocal()'>Inloggen</button>` +
            `<button class='btn' onclick='registerLocal()'>Registreren</button>` +
            `<button class='btn' onclick='showHint()'>Toon hint</button>` +
            `</div>` +
          `</div>`;
        }
        c.innerHTML = loginHtml;
        return;
      }
      // lijsten
      const map={huiswerk:'huiswerk',toetsen:'toets',leren:'leren',extra:'extra'};
      const cat=map[route];
      const base=(getHide()?tasks.filter(t=>!t.done):tasks).filter(t=>catEnabled(t.category||'anders'));
      const its=base.filter(t=>t.category===cat);
      c.innerHTML = toolbar('hide') + `<div style='display:flex;gap:6px;margin:6px 0'><button class='btn' onclick="newTask('${cat}')">+ ${t(route)} ${t('add')}</button></div>` + (its.length?its.map(renderPillHtml).join(''):empty());
    }
    // kalender views
function dayItems(dayISO){
  // Begin met alle taken die aan de categorie-filter voldoen
  let list = tasks.filter(t => catEnabled(t.category || 'anders'));
  // Pas verbergen van afgevinkte taken toe indien van toepassing
  if(getHide()){
    list = list.filter(t => {
      // Voor niet-herhalende taken: verberg als t.done waar is
      if(!t.repeat || t.repeat === 'none'){
        return !t.done;
      }
      // Voor herhalende taken: verberg als deze herhaling is afgevinkt voor de dag
      if(Array.isArray(t.doneDates) && t.doneDates.includes(dayISO)){
        return false;
      }
      // Anders zichtbaar
      return true;
    });
  }
  // Geef alleen taken terug die op deze datum voorkomen (oorspronkelijke datum of herhaling)
  return list.filter(t => t.date === dayISO || occursOn(t, dayISO));
}
function renderMonth(){
  const c = el('content');
  el('sub').innerText = ` ${ref.toLocaleString(getLocale(), { month:'long', year:'numeric' })}`;
  const year = ref.getFullYear();
  const month = ref.getMonth();
  // eerste dag van de maand
  const firstOfMonth = new Date(year, month, 1);
  // dagindex waarbij maandag=0, zondag=6
  const firstDayIndex = (firstOfMonth.getDay() + 6) % 7;
  // startdatum is de maandag van de eerste kalenderweek
  const startDate = new Date(year, month, 1 - firstDayIndex);
  let cells = '';
  // toon precies 35 dagen (5 weken)
  for(let i=0; i<35; i++){
    const d = new Date(startDate);
    d.setDate(startDate.getDate() + i);
    const dayISO = iso(d);
    const items = dayItems(dayISO);
    const inCurrent = d.getMonth() === month;
    // style: cell heeft lagere opacity indien buiten huidige maand
    const cellStyle = `border:1px solid var(--b);min-height:82px;padding:4px${inCurrent ? '' : ';opacity:0.5'}`;
    cells += `<div style='${cellStyle}' ondblclick='newTaskOn("${dayISO}")'>${d.getDate()}${items.map(t=>`<span class='stripe' style='background:${t.color||"#3b82f6"}' onclick='openDay("${dayISO}")' title='${t.title||""}'></span>`).join('')}</div>`;
  }
  // zoekveld voor kalender in toolbar
  const searchBox = `<span style='display:flex;align-items:center;gap:2px'><input id='calSearch' placeholder='Zoeken' oninput='searchCalendar(this.value)' style='width:140px'><button class='btn' onclick='searchCalendar(document.getElementById("calSearch").value)' title='Zoeken'>üîç</button></span>`;
  c.innerHTML = toolbar('full', searchBox) + `<div style='display:grid;grid-template-columns:repeat(7,1fr)'>${cells}</div>`;
}
function renderWeek(){
  const c = el('content');
  const s = sow(ref);
  // Toon het datumbereik van de week in de subkop (bijvoorbeeld "1 jan ‚Äì 7 januari 2025").
  el('sub').innerText = ` ${s.toLocaleDateString(getLocale(),{day:'numeric',month:'short'})} ‚Äì ${new Date(s.getFullYear(), s.getMonth(), s.getDate()+6).toLocaleDateString(getLocale(), {day:'numeric', month:'long', year:'numeric'})}`;
  let html = '<div style="display:grid;grid-template-columns:repeat(7,1fr);gap:6px">';
  for(let i=0; i<7; i++){
    const d = new Date(s);
    d.setDate(s.getDate() + i);
    const dayISO = iso(d);
    const items = dayItems(dayISO);
      // Vergroot de minimale hoogte van de weekcel zodat titels niet half worden afgesneden
      html += `<div style='border:1px solid var(--b);min-height:120px;padding:6px' ondblclick='newTaskOn("${dayISO}")'>`;
    // Dagheader met afkorting en datum
    html += `<div style='opacity:.7;font-size:12px'>${d.toLocaleDateString(getLocale(), {weekday:'short', day:'numeric'})}</div>`;
    // Toon elke taak als een gekleurd vakje met een gekleurde stip en eventuele voortgang van subtaken.
      html += items.map(t => {
        // Bereken voortgang van subtaken
        let subCount = 0, doneCount = 0;
        if(Array.isArray(t.subtasks) && t.subtasks.length){
          subCount = t.subtasks.length;
          doneCount = t.subtasks.filter(st => st && st.done).length;
        }
        const progress = subCount ? ` (${doneCount}/${subCount})` : '';
        const baseColor = t.color || "#3b82f6";
        const bgColor = typeof lightenColor === 'function' ? lightenColor(baseColor, 0.5) : baseColor;
        const text = t.title || 'Zonder titel';
        /*
         * Voor de kalenderweekweergave gebruiken we dezelfde stijl als de voormalige roosterweergave.
         * Elk taakblokje bevat een kleine gekleurde stip (in de basiskleur) gevolgd door de titel
         * en optioneel de voortgang van subtaken. De achtergrondkleur is een lichtere variant van
         * de basiskleur zodat het geheel beter leesbaar is.
         */
        return `<div class='stripe' style='height:auto;min-height:18px;display:flex;align-items:center;gap:4px;margin-top:3px;padding:4px 6px;border-radius:4px;cursor:pointer;background:${bgColor};color:var(--text-color);' onclick='openDay("${dayISO}")' title='${text}'>` +
          `<span style='width:8px;height:8px;border-radius:50%;background:${baseColor}'></span>` +
          `<span style='font-size:12px;line-height:1.2;white-space:normal;overflow-wrap:anywhere;'>${text}${progress}</span>` +
          `</div>`;
      }).join('');
    html += `</div>`;
  }
  html += '</div>';
  c.innerHTML = toolbar('full') + html;
}
function renderDay(d){
  // Toon de volledige datum in de subkop
  el('sub').innerText = ` ${d.toLocaleDateString(getLocale(),{weekday:'long',day:'numeric',month:'long',year:'numeric'})}`;
  const c = el('content');
  const dayISO = iso(d);
  const its = dayItems(dayISO).sort((a,b) => (a.start||'99:99').localeCompare(b.start||'99:99'));
  // Geef de ISO-datum door aan renderPillHtml zodat per-dag voltooiing mogelijk is
  c.innerHTML = toolbar('full') + (its.length ? its.map(t => renderPillHtml(t, dayISO)).join('') : empty());
}
    // mini agenda
    function setMini(v){mini=v;render()}
    // Agenda helpers
    function setAgendaDate(val){
      try {
        if(val){
          ref = new Date(val);
          render();
        }
      } catch(e) {
        console.warn('Ongeldige datum voor agenda:', val);
      }
    }
    function setAgendaToday(){
      ref = new Date();
      render();
    }
function renderMiniDay(r,list){
  const dayISO = iso(r);
  const its = list.filter(t => t.date === dayISO || occursOn(t, dayISO)).sort((a,b) => (a.start||'99:99').localeCompare(b.start||'99:99'));
  // header met datum en plus-knop
  const header = `<div style='display:flex;justify-content:space-between;align-items:center;margin:6px 0'>` +
    `<h3 style='margin:0'>${r.toLocaleDateString(getLocale(),{weekday:'long', day:'numeric', month:'long'})}</h3>` +
    `<button class='btn' onclick='newTaskOn("${dayISO}")' type='button' style='height:24px;font-size:12px'>+</button>` +
    `</div>`;
  // Geef dayISO mee aan renderPillHtml zodat herhalende taken per dag
  // kunnen worden afgevinkt
  const content = its.length ? its.map(t => renderPillHtml(t, dayISO)).join('') : empty();
  return header + content;
}

    /*
     * Override de standaard roosterweergave (week) om titels en voortgang van subtaken te tonen
     * en een knop toe te voegen voor het maken van een nieuwe taak op die dag.  
     * Elke dagcel bevat de weekdag met datum, een plus-knop om een nieuwe taak toe te voegen,
     * en per taak een regel met gekleurde stip, titel en voortgang zoals "(done/total)".
     */
    function renderMiniWeek(r, list) {
      const s = sow(r);
      let html = '<div style="display:grid;grid-template-columns:repeat(7,1fr);gap:6px">';
      for (let i = 0; i < 7; i++) {
        const d = new Date(s);
        d.setDate(s.getDate() + i);
        const dayISO = iso(d);
        const items = list.filter(t => t.date === dayISO || occursOn(t, dayISO));
          // Gebruik een flex-container zonder vaste minimale hoogte zodat de hoogte meegroeit met het aantal taken
          html += `<div style='border:1px solid var(--b);padding:6px;display:flex;flex-direction:column' ondblclick='newTaskOn("${dayISO}")'>`;
        // header with day label and add button
        html += `<div style='display:flex;justify-content:space-between;align-items:center;opacity:.7;font-size:12px;margin-bottom:2px'>${d.toLocaleDateString(getLocale(), { weekday:'short', day:'numeric' })}<button class='btn' onclick='event.stopPropagation();newTaskOn("${dayISO}")' type='button' style='font-size:10px;padding:0 4px'>+</button></div>`;
          // tasks list inside day cell
          html += items.map(t => {
            let subCount = 0, doneCount = 0;
            if (Array.isArray(t.subtasks) && t.subtasks.length) {
              subCount = t.subtasks.length;
              doneCount = t.subtasks.filter(st => st && st.done).length;
            }
            const text = t.title || 'Zonder titel';
            const progress = subCount ? ` (${doneCount}/${subCount})` : '';
            // Bepaal basiskleur en maak een lichtere achtergrondvariant voor de hele taak zodat deze als gekleurd vakje wordt weergegeven
            const baseColor = t.color || "#3b82f6";
            const bgColor = lightenColor(baseColor, 0.5);
            // Toon de titel en voortgang op meerdere regels in een blokje met gekleurde achtergrond zodat tekst duidelijk binnen het vak staat
            /*
             * Voor roosterweergave (mini-week) hebben we een eigen layout nodig.
             * We gebruiken wel de klasse 'stripe' zodat de standaard kleur/borderradius
             * behouden blijft, maar overschrijven hier de hoogte zodat de tekst niet
             * wordt afgeknipt. Door height:auto en min-height toe te voegen kan de
             * taak meerdere regels tekst bevatten en netjes binnen het vakje passen.
             */
            return `<div class='stripe' style='height:auto;min-height:14px;display:flex;align-items:center;gap:4px;margin:3px 0;padding:3px 6px;border-radius:4px;cursor:pointer;background:${bgColor};color:var(--text-color);' onclick='openDay("${dayISO}")' title='${text}'>` +
              `<span style='width:8px;height:8px;border-radius:50%;background:${baseColor}'></span>` +
              `<span style='font-size:10px;line-height:1.2;white-space:normal;overflow-wrap:anywhere;'>${text}${progress}</span>` +
              `</div>`;
          }).join('');
        html += `</div>`;
      }
      html += '</div>';
      return html;
    }
    // task UI
function renderPillHtml(t, dayISO){
      // bereken voortgang van subtaken
      let subCount = 0, doneCount = 0;
      if(Array.isArray(t.subtasks) && t.subtasks.length){
        subCount = t.subtasks.length;
        doneCount = t.subtasks.filter(st => st && st.done).length;
      }
      const progressHtml = subCount ? ` <small style='opacity:.7'>(${doneCount}/${subCount})</small>` : '';
      // Subtaak HTML
      let subHtml = '';
      if(subCount){
        subHtml = t.subtasks.map(st => {
          const stDone = st.done ? "checked" : "";
          const stStyle = st.done ? 'text-decoration:line-through;opacity:0.7;' : '';
          return `<div style='display:flex;align-items:center;margin-left:20px;font-size:12px;gap:4px'>
            <input type='checkbox' ${stDone} onchange='toggleSubtask("${t.id}","${st.id}",this.checked)'>
            <span style='flex:1;${stStyle}'>${st.title}</span>
          </div>`;
        }).join('');
      }
        // Bijlagen tonen als klikbare links onder de subtaken (indien aanwezig)
        if(Array.isArray(t.files) && t.files.length){
          const attachments = t.files.map(f => {
            const name = f.name || 'bijlage';
            const url = f.data || '';
            // Gebruik een data-attribuut zodat het volledige data-URI niet in het onclick-argument hoeft. De functie
            // openFile wordt dan aangeroepen met de waarde uit data-url. Hiermee voorkomen we dat de browser
            // standaard het bestand downloadt; in plaats daarvan opent de bijlage in een nieuw tabblad.
            return `<div style='display:flex;align-items:center;margin-left:20px;font-size:12px;gap:4px'>
              <a href='#' data-url="${url}" data-name="${name}" onclick='openAttachmentViewer(this.dataset.url, this.dataset.name); return false;' style='color:inherit;text-decoration:underline;'>üìé ${name}</a>
            </div>`;
          }).join('');
          subHtml += attachments;
        }
      // Bepaal of de titel zichtbaar moet zijn; in de kalenderweergave willen we juist geen titel tonen
      const showTitle = (typeof route !== 'undefined' ? route !== 'kalender' : true);
      // Titeltekst of een lege string afhankelijk van showTitle
      const titleText = showTitle ? (t.title || 'Zonder titel') : '';
      // Bereid datumtekst voor; gebruik lokale datumweergave indien mogelijk
      let dateText = '';
      if (t.date) {
        try {
          const dObj = new Date(t.date);
          // Toon dag en maand (bijv. 3 nov) onder de tijd
          dateText = dObj.toLocaleDateString(getLocale(), { day:'numeric', month:'short' });
        } catch {}
      }
      // Bouw het HTML-blok voor datum en tijd. We tonen de datum boven de tijd,
      // behalve in de roosterweergave: daar worden datum en tijd niet getoond.
      let timeDateHtml = '';
      const hideTimeInRooster = (typeof route !== 'undefined' && route === 'rooster');
      if (!hideTimeInRooster) {
        if (t.start) {
          const timeStr = t.start + (t.end ? '‚Äì' + t.end : '');
          if (dateText) {
            // datum eerst, tijd eronder
            timeDateHtml = `<small style='opacity:.7;display:flex;flex-direction:column;'>${dateText}<span style='margin-top:2px'>${timeStr}</span></small>`;
          } else {
            timeDateHtml = `<small style='opacity:.7'>${timeStr}</small>`;
          }
        } else if (dateText) {
          timeDateHtml = `<small style='opacity:.7'>${dateText}</small>`;
        }
      }
      // Bepaal of de taak op deze dag is voltooid. Voor herhalende taken
      // gebruiken we een doneDates-array zodat elke herhaling afzonderlijk kan
      // worden afgevinkt. Voor niet-herhalende taken blijven we de boolean
      // property t.done gebruiken.
      let isDone = false;
      if(dayISO && t.repeat && t.repeat !== 'none'){
        if(Array.isArray(t.doneDates)){
          isDone = t.doneDates.includes(dayISO);
        }
      } else {
        isDone = !!t.done;
      }
      // CSS-klasse 'done' toepassen op basis van de bovenstaande berekening
      const doneClass = isDone ? 'done' : '';
      return `<div class='pill ${doneClass}' style='border-color:${t.color||"#334155"}'>
        <span style='display:flex;align-items:center;gap:6px'>
          <input type='checkbox' ${isDone?"checked":""} onchange='toggleDone("${t.id}",this.checked${dayISO?`,"${dayISO}"`:''})'>
          <span onclick='openEdit("${t.id}")' style='cursor:pointer'>${titleText}${progressHtml}</span>
          ${timeDateHtml}
        </span>
        <span>
          <button class='btn' title='Voorlezen' onclick='speakTask("${(t.title||"").replace(/"/g,"&quot;")}")'>üîä</button>
          <button class='btn' title='Inspreken' onclick='recordTask("${t.id}")'>üéôÔ∏è</button>
          <button class='btn' title='Bewerken' onclick='openEdit("${t.id}")'>‚úèÔ∏è</button>
          <!-- Alleen voor herhalende taken: knoop om deze herhaling te verwijderen. Hierdoor
               wordt de taak op deze dag overgeslagen, maar blijven andere herhalingen intact. -->
          ${dayISO && t.repeat && t.repeat !== 'none' ? `<button class='btn' title='Verwijder deze herhaling' onclick='deleteOccurrence("${t.id}","${dayISO}")'>üóëÔ∏è</button>` : ''}
        </span>
        ${subHtml}
      </div>`;
    }
/**
 * Markeer een taak als voltooid of niet voltooid. Bij herhalende taken wordt
 * de status per datum opgeslagen in een array `doneDates` zodat elke
 * herhaling afzonderlijk kan worden afgevinkt. Bij niet-herhalende taken
 * blijft de boolean property `t.done` bestaan.
 *
 * @param {string} id - ID van de taak
 * @param {boolean} v - Nieuwe done-status
 * @param {string} [dayISO] - ISO-datum (YYYY-MM-DD) van de herhaling die
 *   wordt gewijzigd. Indien niet opgegeven, wordt de globale done-status
 *   gebruikt (voor niet-herhalende taken).
 */
function toggleDone(id,v,dayISO){
  const t = tasks.find(x => x.id === id);
  if(!t) return;
  // Herhalende taak: status per datum bewaren
  if(dayISO && t.repeat && t.repeat !== 'none'){
    if(!Array.isArray(t.doneDates)) t.doneDates = [];
    const idx = t.doneDates.indexOf(dayISO);
    if(v){
      // markeer als voltooid voor deze dag
      if(idx < 0) t.doneDates.push(dayISO);
    } else {
      // markeer als niet voltooid voor deze dag
      if(idx >= 0) t.doneDates.splice(idx, 1);
    }
  } else {
    // Niet-herhalende taak: eenvoudige boolean
    t.done = !!v;
  }
  save();
  render();
}

    // Markeer een subtaak als voltooid of niet voltooid
    function toggleSubtask(taskId, subId, val){
      const task = tasks.find(x => x.id === taskId);
      if(!task || !Array.isArray(task.subtasks)) return;
      const st = task.subtasks.find(s => s.id === subId);
      if(!st) return;
      st.done = !!val;
      save();
      render();
    }

  /**
   * Verwijder een enkele herhaling van een taak op een bepaalde datum. Dit
   * voegt de datum toe aan de array `skipDates` zodat de taak op die dag
   * wordt overgeslagen. Deze functie heeft geen effect op niet-herhalende
   * taken; die kunnen via het bewerkvenster volledig worden verwijderd.
   *
   * @param {string} id - ID van de taak
   * @param {string} dayISO - ISO-datum (YYYY-MM-DD) van de herhaling die
   *   verwijderd wordt
   */
  function deleteOccurrence(id, dayISO){
    const t = tasks.find(x => x.id === id);
    if(!t) return;
    // Alleen van toepassing op herhalende taken
    if(!dayISO || !t.repeat || t.repeat === 'none') return;
    if(!Array.isArray(t.skipDates)) t.skipDates = [];
    if(!t.skipDates.includes(dayISO)){
      t.skipDates.push(dayISO);
      save();
      render();
    }
  }
    function openDay(dayISO){view='day';ref=new Date(dayISO);route='kalender';render()}
    function newTask(cat){openEdit(null);setTimeout(()=>{const s=el('tcat');if(s&&cat)s.value=cat},0)}
    function newTaskOn(dayISO){
      // Open het dialoogvenster voor een nieuwe taak en vul de datum vooraf in.
      // Indien we ons op de roosterpagina bevinden, stel dan standaard de categorie in op 'rooster' zodat
      // nieuwe taken automatisch zichtbaar zijn in het roosteroverzicht.  Op andere pagina's behoudt het
      // formulier de standaardcategorie (anders).
      openEdit(null);
      setTimeout(() => {
        const d = el('tdate');
        if (d) d.value = dayISO;
        // Indien de gebruiker een taak aanmaakt via de roosterpagina, werd voorheen
        // automatisch de categorie 'rooster' ingesteld zodat de taak zichtbaar was in het
        // roosteroverzicht. Omdat de categorie 'rooster' is verwijderd, stellen we
        // geen speciale categorie meer in; het formulier behoudt de standaardwaarde
        // (anders) of de laatst gekozen categorie.
        const csel = el('tcat');
        if (csel && typeof route !== 'undefined' && route === 'rooster') {
          csel.value = csel.value || 'anders';
        }
      }, 0);
    }
    // header & nav
    el('prev').onclick=()=>{if(route!=='kalender')return;ref=(view==='month')?new Date(ref.getFullYear(),ref.getMonth()-1,1):new Date(ref.getFullYear(),ref.getMonth(),ref.getDate()-(view==='week'?7:1));render()};
    el('next').onclick=()=>{if(route!=='kalender')return;ref=(view==='month')?new Date(ref.getFullYear(),ref.getMonth()+1,1):new Date(ref.getFullYear(),ref.getMonth(),ref.getDate()+(view==='week'?7:1));render()};
    el('today').onclick=()=>{ref=new Date();render()};
    el('new').onclick=()=>newTaskOn(iso(ref));
    document.querySelectorAll('.v').forEach(b=>b.onclick=()=>{document.querySelectorAll('.v').forEach(x=>x.classList.remove('active'));b.classList.add('active');view=b.dataset.v;route='kalender';render()});
    Array.from(document.querySelectorAll('#menu a')).forEach(a=>a.addEventListener('click',e=>{e.preventDefault();Array.from(document.querySelectorAll('#menu a')).forEach(x=>x.classList.remove('active'));a.classList.add('active');route=a.dataset.route;render()}));
    document.addEventListener('keydown',e=>{const t=(document.activeElement||{}).tagName||'';if(['INPUT','TEXTAREA','SELECT','BUTTON','DIALOG'].includes(t))return;if(e.key==='ArrowLeft'){e.preventDefault();el('prev').click()}else if(e.key==='ArrowRight'){e.preventDefault();el('next').click()}});
    // edit dialog
function openEdit(id){
      const d = el('dlg');
      // Zoek bestaande taak of maak een nieuwe lege taak
      const t = id ? tasks.find(x => x.id === id) : {
        id: crypto.randomUUID(),
        title: '',
        // Laat datum standaard leeg zodat taken zonder datum mogelijk zijn. De datum wordt alleen vooringevuld wanneer een dag expliciet wordt gekozen (bijv. via de kalender).
        date: '',
        color: '#3b82f6',
        category: 'anders',
        repeat: 'none',
        files: []
      };
      // Vul formulier velden
      el('tid').value = t.id;
      el('ttitle').value = t.title || '';
      // Zet de datumvelden. Laat de datum leeg als er geen datum is zodat taken zonder datum mogelijk zijn.
      el('tdate').value = t.date || '';
      // Stel de einddatum in indien beschikbaar. Als er geen einddatum is, laat leeg zodat taken slechts √©√©n dag duren.
      const edInput = el('tenddate');
      if (edInput) edInput.value = t.endDate || '';
      el('tcolor').value = t.color || '#3b82f6';
      el('tstart').value = t.start || '';
      el('tend').value = t.end || '';
      el('tcat').value = t.category || 'anders';
      el('trepeat').value = t.repeat || 'none';
      // Knoppen voor verwijderen en opslaan
      el('tdel').onclick = () => {
        if (id) {
          delTask(id);
          d.close();
        }
      };
      el('tsave').onclick = (e) => {
        e.preventDefault();
        saveFromDialog();
      };
      // microfoon en voorlezen
      el('micTitle').onclick = () => mic(el('ttitle'));
      el('speakTitle').onclick = () => speak(el('ttitle').value || '');
      // Reset file input
      const finput = el('tfiles');
      if (finput) finput.value = '';
      // Toon bestaande bijlagen
      const preview = el('filePreview');
      if (preview) {
        preview.innerHTML = '';
        const list = t.files || [];
        list.forEach((file, idx) => {
          // Maak een rij om de bestandsnaam en verwijderknop te bevatten
          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.alignItems = 'center';
          row.style.gap = '4px';
            // Klikbare link om het bestand te openen. Gebruik een onclick handler die openFile aanroept zodat
            // de bijlage daadwerkelijk wordt geopend in een nieuw tabblad in plaats van automatisch te downloaden.
            const link = document.createElement('a');
            link.href = '#';
            link.textContent = file.name;
            link.style.flex = '1';
            link.addEventListener('click', function(ev){
              ev.preventDefault();
              try { openAttachmentViewer(file.data, file.name || ''); } catch {}
            });
          // Verwijderknop
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn';
          btn.textContent = '‚úñ';
          btn.onclick = () => removeFile(t.id, idx);
          row.appendChild(link);
          row.appendChild(btn);
          preview.appendChild(row);
        });
      }

      // Vul subtaaktekstveld met bestaande subtaken (elk op een nieuwe regel)
      const subInput = el('subtaskInput');
      if(subInput){
        const subs = Array.isArray(t.subtasks) ? t.subtasks : [];
        subInput.value = subs.map(st => st.title || '').join('\n');
      }
      // Toon dialoog
      d.showModal();
    }
async function saveFromDialog(){
      // bouw taakobject
      const id = el('tid').value || crypto.randomUUID();
      const title = (el('ttitle').value || 'Zonder titel').trim();
      // Lees de datumwaarde uit het formulier. Laat deze leeg wanneer de gebruiker geen datum kiest.
      const date = el('tdate').value || '';
      const endDate = el('tenddate').value || '';
      const color = el('tcolor').value || '#3b82f6';
      const start = el('tstart').value || undefined;
      const end = el('tend').value || undefined;
      const category = el('tcat').value || 'anders';
      const repeat = el('trepeat').value || 'none';
      // zoek bestaande taak om bestaande bestanden te behouden
      const existingIndex = tasks.findIndex(x => x.id === id);
      const existingTask = existingIndex >= 0 ? tasks[existingIndex] : null;
      let files = [];
      if (existingTask && Array.isArray(existingTask.files)) {
        // behoud bestaande bijlagen
        files = existingTask.files.slice();
      }
      // lees nieuw geselecteerde bestanden
      const finput = el('tfiles');
      if (finput && finput.files && finput.files.length) {
        const newFiles = await Promise.all(Array.from(finput.files).map(file => new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            resolve({ name: file.name, data: e.target.result });
          };
          reader.readAsDataURL(file);
        })));
        files = files.concat(newFiles);
      }
      // vorm nieuwe taak
      // verzamel subtaken uit het tekstveld
      const subs = [];
      const subInput = el('subtaskInput');
      if(subInput){
        const lines = subInput.value.split(/\n/).map(l => l.trim()).filter(Boolean);
        const existingSubs = existingTask && Array.isArray(existingTask.subtasks) ? existingTask.subtasks : [];
        lines.forEach(line => {
          const existing = existingSubs.find(st => (st.title || '') === line);
          subs.push({ id: existing ? existing.id : crypto.randomUUID(), title: line, done: existing ? !!existing.done : false });
        });
      }
      const task = {
        id,
        title,
        date,
        endDate,
        color,
        start,
        end,
        category,
        repeat,
        done: existingTask ? existingTask.done : false,
        files,
        subtasks: subs
      };
      if (existingIndex >= 0) {
        tasks[existingIndex] = { ...existingTask, ...task };
      } else {
        tasks.push(task);
      }
      save();
      el('dlg').close();
      render();
    }

    // Verwijder een bestand uit een taak en heropen het dialoogvenster
    function removeFile(taskId, index){
      const t = tasks.find(x => x.id === taskId);
      if (!t || !Array.isArray(t.files)) return;
      t.files.splice(index, 1);
      save();
      // Heropen dialoog om de wijzigingen weer te geven
      openEdit(taskId);
    }
    function delTask(id){tasks=tasks.filter(x=>x.id!==id);save();render()}

    /**
     * Open een bijlage in een nieuw tabblad. Sommige browsers downloaden
     * data-URI‚Äôs automatisch wanneer ze rechtstreeks in een hyperlink staan.
     * Door window.open te gebruiken forceren we dat de inhoud geopend
     * wordt in plaats van meteen te downloaden. Als dit om welke reden dan ook
     * mislukt, cre√´ren we een tijdelijk anker en klikken we het programmatisch aan.
     * @param {string} url De data-URI of bestands-URL van de bijlage
     */
    function openFile(url){
      if(!url) return;
      try{
        const newWin = window.open(url, '_blank');
        // in sommige browsers keert window.open null terug wanneer pop-ups worden geblokkeerd
        if(!newWin){
          throw new Error('Kon geen nieuw venster openen');
        }
      }catch(e){
        // fallback: gebruik tijdelijk anker
        try{
          const a = document.createElement('a');
          a.href = url;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        }catch{}
      }
    }

    /**
     * Toon een bijlage in een overliggende viewer met een iframe. De viewer ondersteunt
     * alle bestandsformaten die de browser zelf kan weergeven (zoals pdf, afbeeldingen of Office‚Äëdocumenten
     * wanneer er een plugin aanwezig is). Wanneer de url een data-URI is, proberen we deze
     * asynchroon te converteren naar een Blob zodat het iframe de inhoud beter kan laden.
     * @param {string} url De data-URI of bestands-URL van de bijlage
     * @param {string} name De naam van de bijlage (titel boven in viewer)
     */
    function openAttachmentViewer(url, name){
      try{
        const viewer = document.getElementById('fileViewer');
        const frame = document.getElementById('fileFrame');
        const label = document.getElementById('fileName');
        if(!viewer || !frame){ openFile(url); return; }
        label && (label.textContent = name || '');
        // Toon eerst lege frame om oude inhoud te wissen
        frame.src = '';
        viewer.style.display = 'flex';
        // Data‚ÄëURI direct toewijzen werkt meestal, maar om betere compatibiliteit te bieden
        // converteren we deze naar een blob en gebruiken we een object URL.
        if(url && url.startsWith('data:')){
          try{
            fetch(url).then(r => r.blob()).then(blob => {
              const objectURL = URL.createObjectURL(blob);
              frame.src = objectURL;
            }).catch(() => { frame.src = url; });
          }catch{
            frame.src = url;
          }
        } else {
          frame.src = url || '';
        }
      }catch(e){
        // fallback: open in nieuw tabblad
        openFile(url);
      }
    }
    function closeAttachmentViewer(){
      const viewer = document.getElementById('fileViewer');
      const frame = document.getElementById('fileFrame');
      if(frame) frame.src = '';
      if(viewer) viewer.style.display = 'none';
    }
    // speech
    function speak(txt){
      try{
        const u = new SpeechSynthesisUtterance(txt || '');
        // Use selected voice if available
        const stored = localStorage.getItem('planner.voice');
        const voices = speechSynthesis.getVoices();
        if(stored && voices && voices.length){
          const chosen = voices.find(v => v.voiceURI === stored);
          if(chosen){ u.voice = chosen; u.lang = chosen.lang; }
        }
        // Fall back to current locale
        if(!u.lang) u.lang = getLocale();
        speechSynthesis.speak(u);
      }catch{}
    }
    function speakTask(t){speak(t)}
function mic(target){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SR){ alert('Inspreken niet ondersteund'); return; }
  const r = new SR();
  r.lang = getLocale();
  r.interimResults = false;
  r.maxAlternatives = 1;
  r.onresult = e => {
    const tRes = e.results[0][0].transcript;
    target.value = (target.value ? target.value + ' ' : '') + tRes;
  };
  try{ r.start(); } catch{}
}
function recordTask(id){
  const task = tasks.find(x=>x.id === id);
  if(!task) return;
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SR){ alert('Inspreken niet ondersteund'); return; }
  const r = new SR();
  r.lang = getLocale();
  r.interimResults = false;
  r.maxAlternatives = 1;
  r.onresult = e => {
    const txt = e.results[0][0].transcript;
    task.title = (task.title ? task.title + ' ' : '') + txt;
    save();
    render();
  };
  try{ r.start(); } catch{}
}

    // ===== Subtasks =====
    /**
     * Voeg een rij voor een subtaak toe aan de lijst in het dialoogvenster.
     * Elke rij bevat een checkbox voor voltooiing, een tekstveld voor de titel en een verwijder-knop.
     * @param {string} sid Unieke ID voor de subtaak
     * @param {string} title De titel van de subtaak
     * @param {boolean} done Of de subtaak is afgevinkt
     */
    function addSubtaskRow(sid, title, done){
      /*
       * Voeg een subtaakregel toe aan de subtaskList. Elke regel bestaat uit:
       * - een checkbox om de subtaak af te vinken (class 'subtask-done')
       * - een tekstlabel met de titel van de subtaak (class 'subtask-title')
       * - een verwijderknop (‚úñ) om de subtaak weer te verwijderen uit de lijst.
       * De regel gebruikt flex-layout zodat de onderdelen netjes naast elkaar staan.
       */
      const container = el('subtaskList');
      if(!container) return;
      // Maak een eenvoudige regel voor de subtaak: een checkbox en een titel.
      const row = document.createElement('div');
      row.dataset.sid = sid;
      // gebruik flex zodat de checkbox en titel netjes naast elkaar staan
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.gap = '4px';
      row.style.width = '100%';
      // achtergrondkleur voor de regel (optioneel). Verwijderd de debugkleur.
      // row.style.background = 'rgba(255,0,0,0.2)';
      // checkbox
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.className = 'subtask-done';
      cb.checked = !!done;
      row.appendChild(cb);
      // titel
      const txt = document.createElement('span');
      txt.className = 'subtask-title';
      txt.textContent = title || '';
      txt.style.fontSize = '12px';
      // laat de tekst zoveel mogelijk ruimte nemen binnen de regel
      txt.style.flex = '1';
      row.appendChild(txt);
      // Voeg de regel toe aan de container
      container.appendChild(row);
    }

    // ===== Relax games =====
    function selectGame(name){
      const area = document.getElementById('gameArea');
      if(!area) return;
      // clear previous content and listeners
      area.innerHTML = '';
      // call appropriate game loader
      if(name === 'snake') startSnake(area);
      else if(name === 'flappy') startFlappy(area);
      else if(name === 'pong') startPong(area);
      else if(name === 'tetris') startTetris(area);
      else if(name === 'memory') startMemory(area);
      else if(name === '2048') start2048(area);
      else if(name === 'tictactoe') startTicTacToe(area);
      else if(name === 'minesweeper') startMinesweeper(area);
      else if(name === 'rps') startRPS(area);
      else if(name === 'whack') startWhack(area);
      else if(name === 'guess') startGuess(area);
      else if(name === 'hangman') startHangman(area);
      else if(name === 'simon') startSimon(area);
    }

    // Snake game
    function startSnake(area){
      // maak area leeg en toon spelregels
      area.innerHTML = '';
      const rules = document.createElement('p');
      rules.style.marginBottom = '6px';
      rules.dataset.ruleKey = 'rulesSnake';
      rules.textContent = t('rulesSnake');
      area.appendChild(rules);
      // scoreboard voor score en high score
      const scoreDiv = document.createElement('div');
      scoreDiv.style.marginBottom = '6px';
      scoreDiv.style.fontWeight = 'bold';
      let high = getHighScore('snake');
      scoreDiv.textContent = t('score') + ': 0 (' + t('highLabel') + ': ' + high + ')';
      area.appendChild(scoreDiv);
      const canvas = document.createElement('canvas');
      canvas.width = 400;
      canvas.height = 400;
      canvas.tabIndex = 0;
      canvas.style.background = '#0b1220';
      canvas.style.display = 'block';
      canvas.style.margin = '0 auto';
      area.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      const cell = 20;
      let snake = [{x:10, y:10}];
      let dir = {x:1, y:0};
      let food = spawnFood();
      let gameOver = false;
      let score = 0;
      // scoreboard wordt nu bovenaan toegevoegd (zie hierboven)
      function spawnFood(){
        return { x: Math.floor(Math.random()*20), y: Math.floor(Math.random()*20) };
      }
      function draw(){
        ctx.fillStyle = '#0b1220';
        ctx.fillRect(0,0,400,400);
        // food
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(food.x*cell, food.y*cell, cell, cell);
        // snake
        ctx.fillStyle = '#3b82f6';
        snake.forEach(s=>{ ctx.fillRect(s.x*cell, s.y*cell, cell-1, cell-1); });
      }
      function update(){
        const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
        // hit wall -> game over
        if(head.x < 0 || head.x >= 20 || head.y < 0 || head.y >= 20){ gameOver = true; }
        // collision with self
        for(let i=0;i<snake.length;i++){
          if(snake[i].x === head.x && snake[i].y === head.y){ gameOver = true; break; }
        }
        snake.unshift(head);
        if(head.x === food.x && head.y === food.y){
          food = spawnFood();
          score++;
          // update high score display
          scoreDiv.textContent = t('score') + ': ' + score + ' (' + t('highLabel') + ': ' + high + ')';
        } else {
          snake.pop();
        }
        draw();
        if(gameOver){
          clearInterval(timer);
          ctx.fillStyle = '#ef4444';
          ctx.font = '20px sans-serif';
          ctx.fillText('Game over', 140, 200);
          // update high score if player achieved a new record
          if(score > high){
            high = score;
            setHighScore('snake', high);
          }
          // show final score and high score
          scoreDiv.textContent = t('score') + ': ' + score + ' (' + t('highLabel') + ': ' + high + ')';
        }
      }
      draw();
      const timer = setInterval(update, 150);
      canvas.addEventListener('keydown', function(e){
        switch(e.key){
          case 'ArrowLeft': if(dir.x !== 1){ dir = {x:-1, y:0}; } break;
          case 'ArrowRight': if(dir.x !== -1){ dir = {x:1, y:0}; } break;
          case 'ArrowUp': if(dir.y !== 1){ dir = {x:0, y:-1}; } break;
          case 'ArrowDown': if(dir.y !== -1){ dir = {x:0, y:1}; } break;
        }
      });
      canvas.focus();
    }

    // Flappy Bird game
    function startFlappy(area){
      // maak area leeg en toon spelregels
      area.innerHTML = '';
      const rules = document.createElement('p');
      rules.style.marginBottom = '6px';
      rules.dataset.ruleKey = 'rulesFlappy';
      rules.textContent = t('rulesFlappy');
      area.appendChild(rules);
      // scoreboard met high score
      const scoreDiv = document.createElement('div');
      scoreDiv.style.marginBottom = '6px';
      scoreDiv.style.fontWeight = 'bold';
      let high = getHighScore('flappy');
      scoreDiv.textContent = t('score') + ': 0 (' + t('highLabel') + ': ' + high + ')';
      area.appendChild(scoreDiv);
      // canvas voor spel
      const canvas = document.createElement('canvas');
      canvas.width = 400;
      canvas.height = 400;
      canvas.tabIndex = 0;
      canvas.style.background = '#0b1220';
      canvas.style.display = 'block';
      canvas.style.margin = '0 auto';
      area.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      let birdY = 200;
      let birdVel = 0;
      const gravity = 0.5;
      const pipes = [];
      let frame = 0;
      let gameOver = false;
      let score = 0;
      // scoreDiv wordt nu bovenaan toegevoegd (zie hierboven)
      function spawnPipe(){
        const topH = Math.floor(Math.random()*180) + 40;
        const gap = 120;
        pipes.push({ x: 400, topH: topH, gapH: gap, scored: false });
      }
      function draw(){
        ctx.fillStyle = '#0b1220';
        ctx.fillRect(0,0,400,400);
        // bird
        ctx.fillStyle = '#facc15';
        ctx.beginPath();
        ctx.arc(80, birdY, 10, 0, Math.PI*2);
        ctx.fill();
        // pipes
        ctx.fillStyle = '#22c55e';
        pipes.forEach(p=>{
          ctx.fillRect(p.x, 0, 40, p.topH);
          ctx.fillRect(p.x, p.topH + p.gapH, 40, 400 - (p.topH + p.gapH));
        });
      }
      function update(){
        birdVel += gravity;
        birdY += birdVel;
        if(frame % 90 === 0) spawnPipe();
        pipes.forEach(p=>{ p.x -= 2; });
        // remove off-screen pipes
        if(pipes.length && pipes[0].x < -50) pipes.shift();
        // collisions
        if(birdY > 390 || birdY < 0){ gameOver = true; }
        pipes.forEach(p=>{
          if(80 + 10 > p.x && 80 - 10 < p.x + 40){
            if(birdY - 10 < p.topH || birdY + 10 > p.topH + p.gapH){ gameOver = true; }
          }
        });
        draw();
        // update score when bird passes pipes
        pipes.forEach(p => {
          if(!p.scored && p.x + 40 < 80 - 10){
            score++;
            p.scored = true;
            scoreDiv.textContent = t('score') + ': ' + score + ' (' + t('highLabel') + ': ' + high + ')';
          }
        });
        frame++;
        if(gameOver){
          clearInterval(timer);
          ctx.fillStyle = '#ef4444';
          ctx.font = '20px sans-serif';
          ctx.fillText(t('gameOver'), 140, 200);
          // update high score if new record
          if(score > high){
            high = score;
            setHighScore('flappy', high);
          }
          // show final score and high score
          scoreDiv.textContent = t('score') + ': ' + score + ' (' + t('highLabel') + ': ' + high + ')';
        }
      }
      draw();
      const timer = setInterval(update, 20);
      // flap on click or space
      function flap(){ birdVel = -7; }
      canvas.addEventListener('click', flap);
      canvas.addEventListener('keydown', function(e){ if(e.key === ' '){ flap(); } });
      canvas.focus();
    }

    // Ping Pong game
    function startPong(area){
      // Maak ruimte leeg
      area.innerHTML = '';
      // Toon spelregels
      const rules = document.createElement('p');
      rules.style.marginBottom = '6px';
      rules.dataset.ruleKey = 'rulesPong';
      rules.textContent = t('rulesPong');
      area.appendChild(rules);
      // Scorebord met high score (alleen jouw punten)
      const scoreDiv = document.createElement('div');
      scoreDiv.style.marginBottom = '6px';
      scoreDiv.style.fontWeight = 'bold';
      let high = getHighScore('pong');
      scoreDiv.textContent = `${t('jij')}: 0 ‚Äì Pieter: 0 (${t('highLabel')}: ${high})`;
      area.appendChild(scoreDiv);
      // Canvas voor spel
      const canvas = document.createElement('canvas');
      canvas.width = 400;
      canvas.height = 400;
      canvas.tabIndex = 0;
      canvas.style.background = '#0b1220';
      canvas.style.display = 'block';
      canvas.style.margin = '0 auto';
      area.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      // paddles
      let playerX = 160;
      let cpuX = 160;
      const paddleW = 80;
      const paddleH = 10;
      // bal
      let ball = { x: 200, y: 200, vx: 3, vy: 3, r: 8 };
      let playerScore = 0;
      let cpuScore = 0;
      // reset bal naar midden; richting bepaalt wie punt maakt (cpu als speler miste)
      function resetBall(direction){
        ball.x = 200;
        ball.y = 200;
        // willekeurige horizontale snelheid tussen -3 en 3, maar niet te langzaam
        let hv = (Math.random() * 4 - 2);
        if(Math.abs(hv) < 1) hv = hv < 0 ? -1 : 1;
        ball.vx = hv;
        ball.vy = direction === 'player' ? 3 : -3;
      }
      // update scoreboard UI
      function updateScore(){
        scoreDiv.textContent = `${t('jij')}: ${playerScore} ‚Äì Pieter: ${cpuScore} (${t('highLabel')}: ${high})`;
      }
      function draw(){
        ctx.fillStyle = '#0b1220';
        ctx.fillRect(0,0,400,400);
        // CPU paddle (top)
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(cpuX, 10, paddleW, paddleH);
        // player paddle (bottom)
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(playerX, 380, paddleW, paddleH);
        // ball
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
        ctx.fill();
      }
      function update(){
        // beweeg CPU paddle naar bal
        const targetX = ball.x - paddleW/2;
        cpuX += (targetX - cpuX) * 0.05;
        cpuX = Math.max(0, Math.min(400 - paddleW, cpuX));
        // beweeg bal
        ball.x += ball.vx;
        ball.y += ball.vy;
        // horizontale muren
        if(ball.x - ball.r < 0 || ball.x + ball.r > 400){ ball.vx *= -1; }
        // botsing met CPU paddle (boven)
        if(ball.y - ball.r <= 10 + paddleH){
          if(ball.x >= cpuX && ball.x <= cpuX + paddleW && ball.vy < 0){
            ball.vy *= -1;
            // vergroot snelheid lichtjes
            ball.vx *= 1.05;
            ball.vy *= 1.05;
          } else if(ball.y - ball.r < 0){
            // speler scoort
            playerScore++;
            // check high score
            if(playerScore > high){ high = playerScore; setHighScore('pong', high); }
            updateScore();
            resetBall('cpu');
            // Check win condition: eerste tot drie punten
            if(playerScore >= 3){
              clearInterval(timer);
              // toon game over met winnaar
              ctx.fillStyle = '#22c55e';
              ctx.font = '20px sans-serif';
              ctx.fillText('Je wint!', 150, 200);
              return;
            }
          }
        }
        // botsing met speler paddle (onder)
        if(ball.y + ball.r >= 380){
          if(ball.x >= playerX && ball.x <= playerX + paddleW && ball.vy > 0){
            ball.vy *= -1;
            // pas horizontale snelheid aan op basis van raakpunt
            const hitPos = (ball.x - playerX - paddleW/2) / (paddleW/2);
            ball.vx = ball.vx + hitPos * 2;
            // verhoog snelheid
            ball.vx *= 1.05;
            ball.vy *= 1.05;
          } else if(ball.y + ball.r > 400){
            // CPU scoort
            cpuScore++;
            updateScore();
            resetBall('player');
            // Check win condition: eerste tot drie punten
            if(cpuScore >= 3){
              clearInterval(timer);
              ctx.fillStyle = '#ef4444';
              ctx.font = '20px sans-serif';
              // toon winnaar met naam van de tegenstander
              ctx.fillText('Pieter wint!', 140, 200);
              return;
            }
          }
        }
        draw();
      }
      updateScore();
      draw();
      const timer = setInterval(update, 20);
      canvas.addEventListener('keydown', function(e){
        if(e.key === 'ArrowLeft'){ playerX = Math.max(0, playerX - 20); }
        if(e.key === 'ArrowRight'){ playerX = Math.min(400 - paddleW, playerX + 20); }
      });
      canvas.focus();
    }

    /* Tycoon game is verwijderd */

    // Tetris game
    function startTetris(area){
      area.innerHTML = '';
      // spelregels voor Tetris
      const rules = document.createElement('p');
      rules.style.marginBottom = '6px';
      rules.dataset.ruleKey = 'rulesTetris';
      rules.textContent = t('rulesTetris');
      area.appendChild(rules);
      // score display with high score
      const scoreDiv = document.createElement('div');
      scoreDiv.style.margin = '0 0 6px';
      scoreDiv.style.fontWeight = 'bold';
      let high = getHighScore('tetris');
      scoreDiv.textContent = t('score') + ': 0 (' + t('highLabel') + ': ' + high + ')';
      area.appendChild(scoreDiv);
      const canvas = document.createElement('canvas');
      const cols = 10;
      const rows = 20;
      const block = 20;
      canvas.width = cols * block;
      canvas.height = rows * block;
      canvas.style.background = '#0b1220';
      canvas.style.display = 'block';
      canvas.style.margin = '0 auto';
      area.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      // board: rows x cols, stores color strings or null
      let board = Array.from({length: rows}, () => Array(cols).fill(null));
      // define tetromino shapes and colors
      const SHAPES = [
        { shape: [[1,1,1,1]], color: '#f87171' }, // I
        { shape: [[0,1,0],[1,1,1]], color: '#60a5fa' }, // T
        { shape: [[1,0,0],[1,1,1]], color: '#34d399' }, // J
        { shape: [[0,0,1],[1,1,1]], color: '#facc15' }, // L
        { shape: [[1,1],[1,1]], color: '#f97316' }, // O
        { shape: [[0,1,1],[1,1,0]], color: '#a855f7' }, // S
        { shape: [[1,1,0],[0,1,1]], color: '#ec4899' }  // Z
      ];
      let current = null;
      let currentPos = { x: 0, y: 0 };
      let gameOver = false;
      let score = 0;
      // rotation function
      function rotate(shape){
        const h = shape.length;
        const w = shape[0].length;
        const res = [];
        for(let x=0;x<w;x++){
          const row = [];
          for(let y=h-1;y>=0;y--){
            row.push(shape[y][x]);
          }
          res.push(row);
        }
        return res;
      }
      function createPiece(){
        const p = SHAPES[Math.floor(Math.random()*SHAPES.length)];
        return { shape: p.shape.map(r=>r.slice()), color: p.color };
      }
      function collides(b, piece, pos){
        for(let y=0;y<piece.shape.length;y++){
          for(let x=0;x<piece.shape[y].length;x++){
            if(!piece.shape[y][x]) continue;
            const bx = pos.x + x;
            const by = pos.y + y;
            if(bx < 0 || bx >= cols || by >= rows) return true;
            if(by >= 0 && b[by][bx]) return true;
          }
        }
        return false;
      }
      function merge(b, piece, pos){
        for(let y=0;y<piece.shape.length;y++){
          for(let x=0;x<piece.shape[y].length;x++){
            if(piece.shape[y][x]){
              const bx = pos.x + x;
              const by = pos.y + y;
              if(by>=0 && bx>=0) b[by][bx] = piece.color;
            }
          }
        }
      }
      function clearLines(){
        let lines = 0;
        for(let y=rows-1; y>=0; y--){
          if(board[y].every(cell=>cell)){
            board.splice(y,1);
            board.unshift(Array(cols).fill(null));
            lines++;
            y++;
          }
        }
        if(lines>0){
          score += lines * 100;
          // update high score if needed
          if(score > high){ high = score; setHighScore('tetris', high); }
          scoreDiv.textContent = t('score') + ': ' + score + ' (' + t('highLabel') + ': ' + high + ')';
        }
      }
      function newPiece(){
        current = createPiece();
        currentPos.x = Math.floor((cols - current.shape[0].length)/2);
        currentPos.y = -current.shape.length;
        if(collides(board, current, currentPos)){
          gameOver = true;
          draw();
          ctx.fillStyle = '#ef4444';
          ctx.font = '20px sans-serif';
          ctx.fillText(t('gameOver'), 40, 200);
          // update high score at game end if necessary
          if(score > high){ high = score; setHighScore('tetris', high); }
          scoreDiv.textContent = t('score') + ': ' + score + ' (' + t('highLabel') + ': ' + high + ')';
          return;
        }
      }
      function draw(){
        ctx.fillStyle = '#0b1220';
        ctx.fillRect(0,0, canvas.width, canvas.height);
        // draw settled blocks
        for(let y=0;y<rows;y++){
          for(let x=0;x<cols;x++){
            const cell = board[y][x];
            if(cell){
              ctx.fillStyle = cell;
              ctx.fillRect(x*block, y*block, block-1, block-1);
            }
          }
        }
        // draw current piece
        if(current){
          ctx.fillStyle = current.color;
          for(let y=0;y<current.shape.length;y++){
            for(let x=0;x<current.shape[y].length;x++){
              if(current.shape[y][x]){
                const bx = currentPos.x + x;
                const by = currentPos.y + y;
                if(by>=0){
                  ctx.fillRect(bx*block, by*block, block-1, block-1);
                }
              }
            }
          }
        }
      }
      function step(){
        if(gameOver) return;
        // move down
        currentPos.y += 1;
        if(collides(board, current, currentPos)){
          currentPos.y -= 1;
          merge(board, current, currentPos);
          // voeg basispunten toe voor het plaatsen van een stuk
          score += 10;
          // update high score als nodig
          if(score > high){ high = score; setHighScore('tetris', high); }
          clearLines();
          newPiece();
        }
        draw();
      }
      function move(dx){
        currentPos.x += dx;
        if(collides(board, current, currentPos)) currentPos.x -= dx;
        draw();
      }
      function rotatePiece(){
        const rotated = rotate(current.shape);
        const old = current.shape;
        current.shape = rotated;
        if(collides(board, current, currentPos)){
          current.shape = old;
        }
        draw();
      }
      newPiece();
      draw();
      let dropInterval = 500;
      let dropTimer = setInterval(step, dropInterval);
      // controls
      document.addEventListener('keydown', function(ev){
        if(gameOver) return;
        if(ev.key === 'ArrowLeft'){ move(-1); }
        else if(ev.key === 'ArrowRight'){ move(1); }
        else if(ev.key === 'ArrowDown'){ step(); }
        else if(ev.key === 'ArrowUp'){ rotatePiece(); }
        else if(ev.key === ' '){ // hard drop
          while(!collides(board, current, { x: currentPos.x, y: currentPos.y+1 })){
            currentPos.y += 1;
          }
          step();
        }
      });
    }

    // Memory game
    function startMemory(area){
      area.innerHTML = '';
      // spelregels voor Memory
      const rules = document.createElement('p');
      rules.style.marginBottom = '6px';
      rules.dataset.ruleKey = 'rulesMemory';
      rules.textContent = t('rulesMemory');
      area.appendChild(rules);
      // create scoreboard: toon aantal rondes (beurten) en beste score (laagste rondes)
      const scoreDiv = document.createElement('div');
      scoreDiv.style.marginBottom = '6px';
      scoreDiv.style.fontWeight = 'bold';
      let high = getHighScore('memory');
      // high = 0 betekent nog geen score; toon best indien beschikbaar
      scoreDiv.textContent = t('roundsLabel') + ': 0 (' + t('highLabel') + ': ' + (high || 0) + ')';
      area.appendChild(scoreDiv);
      // track rounds (aantal beurten) i.p.v. gevonden paren
      let rounds = 0;
      // icons for pairs (use emojis)
      const icons = ['üçé','üçå','üçá','üçí','üçë','ü•ù','üçâ','üçç'];
      let cards = icons.concat(icons).map((val, i) => ({ id: i, val, revealed: false, matched: false }));
      // shuffle cards
      cards.sort(() => Math.random() - 0.5);
      let first = null;
      let score = 0;
      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = 'repeat(4, 1fr)';
      grid.style.gap = '6px';
      area.appendChild(grid);
      cards.forEach(card => {
        const cell = document.createElement('div');
        cell.style.background = '#1e293b';
        cell.style.border = '1px solid var(--b)';
        cell.style.borderRadius = '6px';
        cell.style.display = 'flex';
        cell.style.alignItems = 'center';
        cell.style.justifyContent = 'center';
        cell.style.height = '60px';
        cell.style.cursor = 'pointer';
        cell.textContent = '';
        cell.onclick = () => {
          if(card.revealed || card.matched) return;
          // reveal this card
          card.revealed = true;
          cell.textContent = card.val;
          cell.style.background = '#334155';
          // if first card not set
          if(!first){
            first = card;
            return;
          }
          // second card clicked (not same card)
          if(first.id === card.id) return;
          // increment rounds and update scoreboard; update best (lower is beter)
          rounds++;
          if(high === 0 || rounds < high){ high = rounds; setHighScore('memory', rounds); }
          scoreDiv.textContent = t('roundsLabel') + ': ' + rounds + ' (' + t('highLabel') + ': ' + high + ')';
          if(first.val === card.val){
            // match
            first.matched = card.matched = true;
            first = null;
            // check end
            if(cards.every(c => c.matched)){
              const msg = document.createElement('div');
              msg.style.marginTop = '8px';
              msg.style.color = '#22c55e';
              msg.textContent = t('memoryCongrats');
              area.appendChild(msg);
            }
          } else {
            // no match: hide both after delay
            const prev = first;
            setTimeout(() => {
              prev.revealed = false;
              card.revealed = false;
              // update cell texts
              grid.childNodes.forEach((child, idx) => {
                const c = cards[idx];
                if(!c.matched && !c.revealed){ child.textContent = ''; child.style.background = '#1e293b'; }
              });
            }, 700);
            first = null;
          }
        };
        grid.appendChild(cell);
      });
    }

    // 2048 game
    function start2048(area){
      area.innerHTML = '';
      // spelregels voor 2048
      const rules = document.createElement('p');
      rules.style.marginBottom = '6px';
      rules.dataset.ruleKey = 'rules2048';
      rules.textContent = t('rules2048');
      area.appendChild(rules);
      const scoreDiv = document.createElement('div');
      scoreDiv.style.marginBottom = '6px';
      scoreDiv.style.fontWeight = 'bold';
      let high = getHighScore('2048');
      scoreDiv.textContent = t('score') + ': 0 (' + t('highLabel') + ': ' + high + ')';
      area.appendChild(scoreDiv);
      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = 'repeat(4, 80px)';
      grid.style.gridTemplateRows = 'repeat(4, 80px)';
      grid.style.gap = '4px';
      area.appendChild(grid);
      let board = Array.from({length:4}, () => Array(4).fill(0));
      let score = 0;
      function randomTile(){
        const empties = [];
        for(let r=0;r<4;r++) for(let c=0;c<4;c++) if(board[r][c]===0) empties.push({r,c});
        if(!empties.length) return;
        const {r,c} = empties[Math.floor(Math.random()*empties.length)];
        board[r][c] = Math.random() < 0.9 ? 2 : 4;
      }
      function draw(){
        grid.innerHTML = '';
        for(let r=0;r<4;r++){
          for(let c=0;c<4;c++){
            const cell = document.createElement('div');
            cell.style.height = '80px';
            cell.style.width = '80px';
            cell.style.display = 'flex';
            cell.style.alignItems = 'center';
            cell.style.justifyContent = 'center';
            cell.style.borderRadius = '6px';
            const val = board[r][c];
            cell.style.background = val ? '#334155' : '#1e293b';
            cell.style.color = '#f8fafc';
            cell.style.fontWeight = 'bold';
            cell.textContent = val || '';
            grid.appendChild(cell);
          }
        }
        // update high score if current score exceeds
        if(score > high){ high = score; setHighScore('2048', score); }
        scoreDiv.textContent = t('score') + ': ' + score + ' (' + t('highLabel') + ': ' + high + ')';
      }
      function rotateLeft(mat){
        const res = Array.from({length:4}, ()=>Array(4).fill(0));
        for(let r=0;r<4;r++) for(let c=0;c<4;c++) res[3-c][r] = mat[r][c];
        return res;
      }
      function slide(row){
        const arr = row.filter(x=>x);
        for(let i=0;i<arr.length-1;i++){
          if(arr[i] === arr[i+1]){
            arr[i] *= 2;
            score += arr[i];
            arr.splice(i+1,1);
          }
        }
        while(arr.length < 4) arr.push(0);
        return arr;
      }
      function moveLeft(){
        let moved = false;
        for(let r=0;r<4;r++){
          const newRow = slide(board[r]);
          if(newRow.toString() !== board[r].toString()){ moved = true; board[r] = newRow; }
        }
        return moved;
      }
      function moveRight(){
        board = board.map(row => row.reverse());
        const moved = moveLeft();
        board = board.map(row => row.reverse());
        return moved;
      }
      function moveUp(){
        board = rotateLeft(board);
        const moved = moveLeft();
        board = rotateLeft(rotateLeft(rotateLeft(board)));
        return moved;
      }
      function moveDown(){
        board = rotateLeft(rotateLeft(rotateLeft(board)));
        const moved = moveLeft();
        board = rotateLeft(board);
        return moved;
      }
      function hasMoves(){
        for(let r=0;r<4;r++) for(let c=0;c<4;c++){
          if(board[r][c] === 0) return true;
          if(c<3 && board[r][c] === board[r][c+1]) return true;
          if(r<3 && board[r][c] === board[r+1][c]) return true;
        }
        return false;
      }
      function keyHandler(ev){
        let moved = false;
        if(ev.key === 'ArrowLeft') moved = moveLeft();
        else if(ev.key === 'ArrowRight') moved = moveRight();
        else if(ev.key === 'ArrowUp') moved = moveUp();
        else if(ev.key === 'ArrowDown') moved = moveDown();
        if(moved){ randomTile(); draw(); }
        // update highscore
        if(score > high){ high = score; setHighScore('2048', high); }
        scoreDiv.textContent = t('score') + ': ' + score + ' (' + t('highLabel') + ': ' + high + ')';
        if(!hasMoves()){
          document.removeEventListener('keydown', keyHandler);
          const msg = document.createElement('div');
          msg.style.marginTop = '8px';
          msg.style.color = '#ef4444';
          msg.textContent = t('gameOver');
          area.appendChild(msg);
        }
      }
      randomTile(); randomTile(); draw();
      document.addEventListener('keydown', keyHandler);
    }

    // Tic-Tac-Toe game
    function startTicTacToe(area){
      area.innerHTML = '';
      // spelregels voor Tic-Tac-Toe
      const rules = document.createElement('p');
      rules.style.marginBottom = '6px';
      rules.dataset.ruleKey = 'rulesTicTacToe';
      rules.textContent = t('rulesTicTacToe');
      area.appendChild(rules);
      let high = getHighScore('tictactoe');
      let playerWins = 0;
      const scoreDiv = document.createElement('div');
      scoreDiv.style.marginBottom = '6px';
      scoreDiv.style.fontWeight = 'bold';
      scoreDiv.textContent = t('wins') + ': 0 (' + t('highLabel') + ': ' + high + ')';
      area.appendChild(scoreDiv);
      let board = Array(9).fill(null);
      let playerTurn = true;
      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = 'repeat(3, 80px)';
      grid.style.gridTemplateRows = 'repeat(3, 80px)';
      grid.style.gap = '4px';
      area.appendChild(grid);
      function renderTT(){
        grid.innerHTML = '';
        board.forEach((mark,i) => {
          const cell = document.createElement('div');
          cell.style.height = '80px';
          cell.style.width = '80px';
          cell.style.display = 'flex';
          cell.style.alignItems = 'center';
          cell.style.justifyContent = 'center';
          cell.style.fontSize = '32px';
          cell.style.border = '1px solid var(--b)';
          cell.style.borderRadius = '4px';
          cell.style.background = '#1e293b';
          cell.textContent = mark || '';
          if(!mark && playerTurn){
            cell.style.cursor = 'pointer';
            cell.onclick = () => movePlayer(i);
          }
          grid.appendChild(cell);
        });
      }
      function checkWin(b, mark){
        const lines = [
          [0,1,2],[3,4,5],[6,7,8],
          [0,3,6],[1,4,7],[2,5,8],
          [0,4,8],[2,4,6]
        ];
        return lines.some(line => line.every(idx => b[idx] === mark));
      }
      function movePlayer(idx){
        if(board[idx]) return;
        board[idx] = 'X';
        if(checkWin(board,'X')){
          playerWins++;
          if(playerWins > high){ high = playerWins; setHighScore('tictactoe', high); }
          scoreDiv.textContent = t('wins') + ': ' + playerWins + ' (' + t('highLabel') + ': ' + high + ')';
          endGame(t('youWin'));
          return;
        }
        if(board.every(x=>x)){
          endGame(t('rpsTie'));
          return;
        }
        playerTurn = false;
        renderTT();
        setTimeout(cpuMove, 300);
      }
      function cpuMove(){
        const empties = board.map((v,i)=> v?null:i).filter(x=>x!==null);
        const idx = empties[Math.floor(Math.random()*empties.length)];
        board[idx] = 'O';
        if(checkWin(board,'O')){
          scoreDiv.textContent = t('wins') + ': ' + playerWins + ' (' + t('highLabel') + ': ' + high + ')';
          endGame(t('rpsCpuWins'));
          return;
        }
        if(board.every(x=>x)){
          endGame(t('rpsTie'));
          return;
        }
        playerTurn = true;
        renderTT();
      }
      function endGame(msg){
        playerTurn = false;
        renderTT();
        const message = document.createElement('div');
        message.style.marginTop = '8px';
        message.style.color = '#22c55e';
        message.textContent = msg;
        area.appendChild(message);
        // reset board after delay
        setTimeout(() => {
          board = Array(9).fill(null);
          playerTurn = true;
          area.innerHTML = '';
          playerWins = 0;
          // update highscore display
          scoreDiv.textContent = t('wins') + ': 0 (' + t('highLabel') + ': ' + high + ')';
          area.appendChild(scoreDiv);
          area.appendChild(grid);
          renderTT();
        }, 2000);
      }
      renderTT();
    }

    // Minesweeper game
    function startMinesweeper(area){
      area.innerHTML = '';
      // spelregels voor Mijnenveger
      const rules = document.createElement('p');
      rules.style.marginBottom = '6px';
      rules.dataset.ruleKey = 'rulesMinesweeper';
      rules.textContent = t('rulesMinesweeper');
      area.appendChild(rules);
      const scoreDiv = document.createElement('div');
      scoreDiv.style.marginBottom = '6px';
      scoreDiv.style.fontWeight = 'bold';
      let high = getHighScore('minesweeper');
      scoreDiv.textContent = t('score') + ': 0 (' + t('highLabel') + ': ' + high + ')';
      area.appendChild(scoreDiv);
      // Voeg een knop toe om de markeer-modus aan of uit te zetten. In markeer-modus worden klikken gebruikt om vlaggen te plaatsen.
      let markMode = false;
      const flagBtn = document.createElement('button');
      flagBtn.className = 'btn';
      flagBtn.style.marginBottom = '6px';
      // Gebruik vertalingen voor de markeermodus-knop
      flagBtn.innerText = t('markModeOff');
      flagBtn.onclick = () => {
        markMode = !markMode;
        flagBtn.innerText = markMode ? t('markModeOn') : t('markModeOff');
      };
      area.appendChild(flagBtn);
      const rows = 8, cols = 8, bombs = 10;
      let board = [];
      for(let r=0;r<rows;r++){
        board[r] = [];
        for(let c=0;c<cols;c++){
          board[r][c] = { bomb:false, revealed:false, flag:false, adjacent:0 };
        }
      }
      // place bombs randomly
      let placed = 0;
      while(placed < bombs){
        const r = Math.floor(Math.random()*rows);
        const c = Math.floor(Math.random()*cols);
        if(!board[r][c].bomb){ board[r][c].bomb = true; placed++; }
      }
      // compute adjacent counts
      const dirs = [-1,0,1];
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          let count = 0;
          if(board[r][c].bomb) continue;
          dirs.forEach(dr => dirs.forEach(dc => {
            if(dr===0 && dc===0) return;
            const nr=r+dr, nc=c+dc;
            if(nr>=0&&nr<rows&&nc>=0&&nc<cols&&board[nr][nc].bomb) count++;
          }));
          board[r][c].adjacent = count;
        }
      }
      let revealedCount = 0;
      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = 'repeat(' + cols + ', 40px)';
      grid.style.gap = '2px';
      area.appendChild(grid);
      function revealCell(r,c){
        const cell = board[r][c];
        if(cell.revealed || cell.flag) return;
        cell.revealed = true;
        const div = grid.children[r*cols + c];
        div.style.background = '#334155';
        if(cell.bomb){
          div.textContent = 'üí£';
          gameOver(false);
          return;
        }
        revealedCount++;
        scoreDiv.textContent = t('score') + ': ' + revealedCount + ' (' + t('highLabel') + ': ' + high + ')';
        if(cell.adjacent > 0){
          div.textContent = cell.adjacent;
        } else {
          // reveal neighbours
          dirs.forEach(dr => dirs.forEach(dc => {
            const nr=r+dr, nc=c+dc;
            if(nr>=0&&nr<rows&&nc>=0&&nc<cols) revealCell(nr,nc);
          }));
        }
        // update highscore if necessary
        if(revealedCount > high){ high = revealedCount; setHighScore('minesweeper', high); }
        if(revealedCount + bombs === rows*cols){
          gameOver(true);
        }
      }
      function gameOver(win){
        // reveal all bombs
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            const cell=board[r][c];
            const div=grid.children[r*cols+c];
            if(cell.bomb){ div.textContent='üí£'; div.style.background='#ef4444'; }
          }
        }
        const msg = document.createElement('div');
        msg.style.marginTop='8px';
        msg.style.color = win? '#22c55e' : '#ef4444';
        msg.textContent = win? t('youWin') : t('gameOver');
        area.appendChild(msg);
        // no further clicks
        grid.querySelectorAll('div').forEach(div => div.onclick = null);
      }
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const div = document.createElement('div');
          div.style.width='40px';
          div.style.height='40px';
          div.style.background='#1e293b';
          div.style.border='1px solid var(--b)';
          div.style.display='flex';
          div.style.alignItems='center';
          div.style.justifyContent='center';
          div.style.cursor='pointer';
          div.onclick = () => {
            const cell = board[r][c];
            // Indien markeer-modus actief is, zet of verwijder een vlag op dit vakje
            if(markMode){
              if(cell.revealed) return;
              cell.flag = !cell.flag;
              div.textContent = cell.flag ? 'üö©' : '';
              return;
            }
            // In normale modus: negeer klikken op gemarkeerde vakjes
            if(cell.flag) return;
            revealCell(r,c);
          };
          grid.appendChild(div);
        }
      }
    }

    // Rock-Paper-Scissors game
    function startRPS(area){
      area.innerHTML = '';
      // scoreboard for wins
      let high = getHighScore('rps');
      let wins = 0;
      const scoreDiv = document.createElement('div');
      scoreDiv.style.marginBottom = '6px';
      scoreDiv.style.fontWeight = 'bold';
      scoreDiv.textContent = t('wins') + ': 0 (' + t('highLabel') + ': ' + high + ')';
      area.appendChild(scoreDiv);
      // rules
      const rules = document.createElement('p');
      rules.style.marginTop = '0';
      rules.style.marginBottom = '8px';
      rules.dataset.ruleKey = 'rulesRPS';
      rules.textContent = t('rulesRPS');
      area.appendChild(rules);
      // buttons for choices
      const choices = ['steen','papier','schaar'];
      const buttonsDiv = document.createElement('div');
      buttonsDiv.style.display = 'flex';
      buttonsDiv.style.gap = '8px';
      area.appendChild(buttonsDiv);
      const resultDiv = document.createElement('div');
      resultDiv.style.marginTop = '8px';
      resultDiv.style.fontWeight = 'bold';
      area.appendChild(resultDiv);
      function play(choice){
        const cpuChoice = choices[Math.floor(Math.random()*3)];
        let message;
        if(choice === cpuChoice){ message = t('rpsTie'); }
        else if(
          (choice==='steen' && cpuChoice==='schaar') ||
          (choice==='papier' && cpuChoice==='steen') ||
          (choice==='schaar' && cpuChoice==='papier')
        ){
          wins++;
          if(wins > high){ high = wins; setHighScore('rps', high); }
          message = t('rpsYouWin') + ' (' + choice + ' vs ' + cpuChoice + ')';
        } else {
          // verlies: reset wins
          wins = 0;
          message = t('rpsCpuWins') + ' (' + choice + ' vs ' + cpuChoice + ')';
        }
        scoreDiv.textContent = t('wins') + ': ' + wins + ' (' + t('highLabel') + ': ' + high + ')';
        resultDiv.textContent = message;
      }
      choices.forEach(ch => {
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = ch.charAt(0).toUpperCase() + ch.slice(1);
        btn.onclick = () => play(ch);
        buttonsDiv.appendChild(btn);
      });
    }

    // Whack-a-Mole game
    function startWhack(area){
      // clear previous interval if exists
      if(area._whackInterval){ clearInterval(area._whackInterval); }
      area.innerHTML = '';
      let high = getHighScore('whack');
      let hits = 0;
      let misses = 0;
      let speed = 800;
      const scoreDiv = document.createElement('div');
      scoreDiv.style.marginBottom = '6px';
      scoreDiv.style.fontWeight = 'bold';
      scoreDiv.textContent = t('score') + ': 0 (' + t('highLabel') + ': ' + high + ')';
      area.appendChild(scoreDiv);
      // rules
      const rules = document.createElement('p');
      rules.style.marginTop = '0';
      rules.style.marginBottom = '8px';
      rules.dataset.ruleKey = 'rulesWhack';
      rules.textContent = t('rulesWhack');
      area.appendChild(rules);
      const gridSize = 3;
      const cellCount = gridSize * gridSize;
      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = 'repeat(' + gridSize + ', 80px)';
      grid.style.gap = '6px';
      area.appendChild(grid);
      const cells = [];
      for(let i=0;i<cellCount;i++){
        const cell = document.createElement('div');
        cell.style.width = '80px';
        cell.style.height = '80px';
        cell.style.border = '1px solid var(--b)';
        cell.style.borderRadius = '6px';
        cell.style.background = '#1e293b';
        cell.style.display = 'flex';
        cell.style.alignItems = 'center';
        cell.style.justifyContent = 'center';
        cell.style.fontSize = '32px';
        cell.style.cursor = 'pointer';
        cell.onclick = () => {
          if(cell.textContent === 'üê≠'){
            // hit
            hits++;
            misses = 0;
            // increase high score if needed
            if(hits > high){ high = hits; setHighScore('whack', high); }
            scoreDiv.textContent = t('score') + ': ' + hits + ' (' + t('highLabel') + ': ' + high + ')';
            cell.textContent = '';
            // speed up the interval slightly, minimum 200ms
            speed = Math.max(200, speed - 20);
            clearInterval(area._whackInterval);
            area._whackInterval = setInterval(showMole, speed);
          } else {
            // miss
            misses++;
            if(misses >= 2){
              // game over: stop interval and clear moles
              clearInterval(area._whackInterval);
              cells.forEach(c => c.textContent = '');
              const over = document.createElement('div');
              over.style.marginTop = '8px';
              over.style.fontWeight = 'bold';
              over.textContent = t('gameOver') || 'Game Over!';
              area.appendChild(over);
            }
          }
        };
        cells.push(cell);
        grid.appendChild(cell);
      }
      function showMole(){
        // clear all mice
        cells.forEach(c => { if(c.textContent === 'üê≠') c.textContent = ''; });
        const idx = Math.floor(Math.random()*cellCount);
        cells[idx].textContent = 'üê≠';
      }
      area._whackInterval = setInterval(showMole, speed);
    }

  // Guess the Number game
  function startGuess(area){
    // clear area
    area.innerHTML = '';
    // rules
    const rules = document.createElement('p');
    rules.style.marginBottom = '6px';
    rules.dataset.ruleKey = 'rulesGuess';
    rules.textContent = t('rulesGuess');
    area.appendChild(rules);
    // scoreboard for attempts and high score (lowest attempts)
    const scoreDiv = document.createElement('div');
    scoreDiv.style.marginBottom = '6px';
    scoreDiv.style.fontWeight = 'bold';
    let high = getHighScore('guess');
    scoreDiv.textContent = t('attemptsLabel') + ': 0 (' + t('highLabel') + ': ' + (high || 0) + ')';
    area.appendChild(scoreDiv);
    // input and button for guessing
    const form = document.createElement('div');
    form.style.display = 'flex';
    form.style.gap = '6px';
    form.style.alignItems = 'center';
    const input = document.createElement('input');
    input.type = 'number';
    input.min = '1';
    input.max = '100';
    input.style.width = '80px';
    input.placeholder = '1-100';
    const button = document.createElement('button');
    button.className = 'btn';
    button.textContent = t('bereken') || 'Raad';
    const resultDiv = document.createElement('div');
    resultDiv.style.marginTop = '8px';
    resultDiv.style.fontWeight = 'bold';
    form.appendChild(input);
    form.appendChild(button);
    area.appendChild(form);
    area.appendChild(resultDiv);
    // game state
    let secret = Math.floor(Math.random()*100) + 1;
    let attempts = 0;
    function resetGame(){
      secret = Math.floor(Math.random()*100) + 1;
      attempts = 0;
      resultDiv.textContent = '';
      scoreDiv.textContent = t('attemptsLabel') + ': 0 (' + t('highLabel') + ': ' + (high || 0) + ')';
      input.value = '';
    }
    function handleGuess(){
      const val = parseInt(input.value, 10);
      if(isNaN(val)) return;
      attempts++;
      // update high score if better (lower attempts) when guessed correctly
      if(val === secret){
        // update highscore
        if(high === 0 || attempts < high){ high = attempts; setHighScore('guess', attempts); }
        const msgTemplate = t('guessedNumber');
        const msg = msgTemplate.replace('{n}', attempts);
        resultDiv.textContent = msg;
        scoreDiv.textContent = t('attemptsLabel') + ': ' + attempts + ' (' + t('highLabel') + ': ' + high + ')';
        // show restart button
        const restartBtn = document.createElement('button');
        restartBtn.className = 'btn';
        restartBtn.style.marginLeft = '6px';
        restartBtn.textContent = t('restart');
        restartBtn.onclick = () => { resetGame(); restartBtn.remove(); };
        form.appendChild(restartBtn);
        return;
      } else if(val < secret){
        resultDiv.textContent = t('higher');
      } else {
        resultDiv.textContent = t('lower');
      }
      if(high === 0 || attempts < high){ /* do not update high yet until guessed */ }
      scoreDiv.textContent = t('attemptsLabel') + ': ' + attempts + ' (' + t('highLabel') + ': ' + (high || 0) + ')';
    }
    button.onclick = handleGuess;
    input.addEventListener('keydown', function(e){ if(e.key === 'Enter'){ handleGuess(); } });
  }

  // Hangman game
  function startHangman(area){
    area.innerHTML = '';
    // rules
    const rules = document.createElement('p');
    rules.style.marginBottom = '6px';
    rules.dataset.ruleKey = 'rulesHangman';
    rules.textContent = t('rulesHangman');
    area.appendChild(rules);
    // scoreboard (wins and high)
    let high = getHighScore('hangman');
    let wins = 0;
    const scoreDiv = document.createElement('div');
    scoreDiv.style.marginBottom = '6px';
    scoreDiv.style.fontWeight = 'bold';
    scoreDiv.textContent = t('wins') + ': 0 (' + t('highLabel') + ': ' + high + ')';
    area.appendChild(scoreDiv);
    // word list
    const words = ['planner','school','coding','computer','vakantie','studie','fruit','tafel','huis','agenda'];
    let secret = '';
    let guessed = [];
    let wrong = 0;
    const displayDiv = document.createElement('div');
    displayDiv.style.fontSize = '24px';
    displayDiv.style.letterSpacing = '4px';
    displayDiv.style.marginBottom = '8px';
    area.appendChild(displayDiv);
    const guessDiv = document.createElement('div');
    guessDiv.style.display = 'flex';
    guessDiv.style.flexWrap = 'wrap';
    guessDiv.style.gap = '4px';
    area.appendChild(guessDiv);
    const resultDiv = document.createElement('div');
    resultDiv.style.marginTop = '8px';
    resultDiv.style.fontWeight = 'bold';
    area.appendChild(resultDiv);
    function newRound(){
      secret = words[Math.floor(Math.random()*words.length)].toUpperCase();
      guessed = [];
      wrong = 0;
      resultDiv.textContent = '';
      updateDisplay();
      // clear letters
      guessDiv.innerHTML = '';
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      letters.split('').forEach(ch => {
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = ch;
        btn.style.width = '30px';
        btn.onclick = () => chooseLetter(ch, btn);
        guessDiv.appendChild(btn);
      });
    }
    function updateDisplay(){
      let disp = '';
      for(let i=0;i<secret.length;i++){
        const c = secret[i];
        disp += guessed.includes(c) ? c + ' ' : '_ ';
      }
      displayDiv.textContent = disp.trim();
    }
    function chooseLetter(ch, btn){
      btn.disabled = true;
      if(secret.includes(ch)){
        guessed.push(ch);
        updateDisplay();
        // check win
        if(secret.split('').every(c => guessed.includes(c))){
          wins++;
          if(wins > high){ high = wins; setHighScore('hangman', wins); }
          scoreDiv.textContent = t('wins') + ': ' + wins + ' (' + t('highLabel') + ': ' + high + ')';
          resultDiv.textContent = t('youWin') || 'Je wint!';
          setTimeout(newRound, 1500);
        }
      } else {
        wrong++;
        resultDiv.textContent = t('wrongGuess') || 'Fout!';
        if(wrong >= 6){
          resultDiv.textContent = t('loseWord') ? t('loseWord').replace('{word}', secret) : ('Je verliest! Het woord was ' + secret);
          wins = 0;
          scoreDiv.textContent = t('wins') + ': ' + wins + ' (' + t('highLabel') + ': ' + high + ')';
          setTimeout(newRound, 1500);
        }
      }
    }
    // add minimal translation keys fallback if not provided
    // start first round
    newRound();
  }

    // Simon game (colour sequence memory)
    function startSimon(area){
      // clear area
      area.innerHTML = '';
      // rules paragraph
      const rules = document.createElement('p');
      rules.style.marginBottom = '6px';
      rules.dataset.ruleKey = 'rulesSimon';
      rules.textContent = t('rulesSimon');
      area.appendChild(rules);
      // scoreboard: rounds and high score
      const scoreDiv = document.createElement('div');
      scoreDiv.style.marginBottom = '6px';
      scoreDiv.style.fontWeight = 'bold';
      let high = getHighScore('simon');
      scoreDiv.textContent = t('roundsLabel') + ': 0 (' + t('highLabel') + ': ' + (high || 0) + ')';
      area.appendChild(scoreDiv);
      // colours and buttons
      const colours = ['red','green','blue','yellow'];
      const names = { red:'üî¥', green:'üü¢', blue:'üîµ', yellow:'üü°' };
      const btnContainer = document.createElement('div');
      btnContainer.style.display = 'grid';
      btnContainer.style.gridTemplateColumns = 'repeat(2, 80px)';
      btnContainer.style.gap = '8px';
      btnContainer.style.marginBottom = '8px';
      area.appendChild(btnContainer);
      const message = document.createElement('div');
      message.style.marginTop = '8px';
      message.style.fontWeight = 'bold';
      area.appendChild(message);
      let sequence = [];
      let userIndex = 0;
      let rounds = 0;
      let accepting = false;
      // create buttons
      const buttons = {};
      colours.forEach(col => {
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.style.height = '60px';
        btn.style.fontSize = '24px';
        btn.textContent = names[col];
        btn.style.backgroundColor = col;
        btn.style.color = '#fff';
        btn.onclick = () => handleClick(col);
        btnContainer.appendChild(btn);
        buttons[col] = btn;
      });
      function flash(col){
        const btn = buttons[col];
        const orig = btn.style.opacity || '1';
        btn.style.opacity = '0.4';
        setTimeout(() => { btn.style.opacity = orig; }, 300);
      }
      function playSequence(){
        accepting = false;
        let i = 0;
        function next(){
          if(i < sequence.length){
            flash(sequence[i]);
            i++;
            setTimeout(next, 500);
          } else {
            accepting = true;
            userIndex = 0;
          }
        }
        next();
      }
      function newRound(){
        // add random colour
        sequence.push(colours[Math.floor(Math.random()*colours.length)]);
        rounds++;
        // In Simon telt een hogere ronde als betere score (langste volgorde). Update highscore indien hoger
        if(rounds > high){ high = rounds; setHighScore('simon', rounds); }
        scoreDiv.textContent = t('roundsLabel') + ': ' + rounds + ' (' + t('highLabel') + ': ' + high + ')';
        playSequence();
      }
      function handleClick(col){
        if(!accepting) return;
        flash(col);
        if(col === sequence[userIndex]){
          userIndex++;
          if(userIndex === sequence.length){
            // round completed
            setTimeout(newRound, 600);
          }
        } else {
          // wrong -> reset
          message.textContent = t('wrongGuess') || 'Fout!';
          rounds = 0;
          sequence = [];
          setTimeout(() => { message.textContent = ''; newRound(); }, 1000);
        }
      }
      // start first round
      newRound();
    }


    // ===== Cijfercalculator =====
    function calcRequiredGrade(){
      const desired = parseFloat(el('calcDesired')?.value || '0');
      const nextW = parseFloat(el('calcWeight')?.value || '0');
      const resultEl = el('calcResult');
      if(!nextW || nextW <= 0){ resultEl.innerText = 'Ongeldige weging'; return; }
      // haal geselecteerd vak op; een lege waarde betekent alle vakken
      const sel = el('calcSubject')?.value || '';
      // filter cijfers op vak indien geselecteerd
      const relevant = sel ? grades.filter(g => g.vak === sel) : grades;
      // bereken totaal gewicht en score
      const totalW = relevant.reduce((sum,g)=>sum + (parseFloat(g.weight)||0), 0);
      const totalS = relevant.reduce((sum,g)=>sum + (parseFloat(g.score)||0)*(parseFloat(g.weight)||0), 0);
      if(!desired || desired <= 0){ resultEl.innerText = 'Voer gewenst gemiddelde in'; return; }
      const needed = ((desired * (totalW + nextW)) - totalS) / nextW;
      if(isNaN(needed)){
        resultEl.innerText = 'N.v.t.';
        return;
      }
      const neededRounded = Math.round(needed * 100) / 100;
      if(neededRounded > 10){ resultEl.innerText = `Je moet hoger dan 10 (${neededRounded}) halen ‚Äì niet mogelijk`; }
      else if(neededRounded < 0){ resultEl.innerText = `Je gemiddelde is al hoger dan ${desired}`; }
      else { resultEl.innerText = `Je hebt een ${neededRounded.toFixed(2)} nodig`; }
    }

    // Hulpfunctie voor vertaalinterface in Instellingen. Haalt de sleutel en taal op,
    // en toont de vertaling in het resultaatvak. Als de sleutel niet bestaat in de
    // woordenlijst, wordt de sleutel zelf weergegeven.
    function doTranslate(){
      const textEl = document.getElementById('transText');
      const fromSel = document.getElementById('transLangFrom');
      const toSel = document.getElementById('transLangTo');
      const resultEl = document.getElementById('transResult');
      if(!resultEl || !textEl || !fromSel || !toSel) return;
      const text = (textEl.value || '').trim();
      const from = fromSel.value || getLang();
      const to = toSel.value || getLang();
      if(!text){ resultEl.innerText = ''; return; }
      // Vertaal elke woord afzonderlijk. Dit splitst de tekst op spaties en probeert elk
      // woord via translateText om te zetten. Als een woord niet wordt gevonden,
      // blijft het origineel behouden.
      const translated = text.split(/\s+/).map(w => translateText(w, from, to)).join(' ');
      resultEl.innerText = translated;
    }
    // achtergrond
    const BKEY='planner.bg.v2';
    // Sla meerdere achtergrondbestanden op, elk met een naam. Deze lijst wordt opgeslagen in localStorage.
    const BGLIST_KEY = 'planner.backgrounds';
    let backgroundsList = [];
    // Laad de opgeslagen achtergronden uit localStorage. Als er geen of ongeldige data is, gebruik een lege array.
    function loadBackgrounds(){
      try{
        const arr = JSON.parse(localStorage.getItem(BGLIST_KEY) || '[]');
        if(Array.isArray(arr)){
          backgroundsList = arr;
        } else {
          backgroundsList = [];
        }
      } catch{
        backgroundsList = [];
      }
    }
    // Sla de huidige lijst van achtergronden op in localStorage.
    function saveBackgrounds(){
      try{
        localStorage.setItem(BGLIST_KEY, JSON.stringify(backgroundsList));
      }catch{}
    }
    // Voeg een nieuwe achtergrond toe aan de lijst met een naam en gegevens-URL. Als de naam leeg is, gebruik het bestandsnummer als fallback.
    function addBackground(name, url){
      if(!url) return;
      // Laad bestaande lijst om dubbele IDs te voorkomen
      loadBackgrounds();
      const nm = (name && name.trim()) ? name.trim() : `Achtergrond ${backgroundsList.length + 1}`;
      // Wanneer een nieuwe afbeelding als achtergrond wordt toegevoegd willen we ook de huidige instellingen opslaan.
      // Deze instellingen omvatten kleuren (tekst, zijbalk, panelen) en hun opaciteiten, alsmede of panelen uitgeschakeld zijn.
      // Zo krijgt elke achtergrond zijn eigen thema. Bestaande keys worden opgehaald via hulpfuncties.
      let settings = {};
      try {
        settings = {
          textColor: getTextColor() || '',
          asideColor: getAsideColor() || '',
          asideOpacity: getAsideOpacity(),
          panelColor: getPanelColor() || '',
          panelOpacity: getPanelOpacity(),
          panelsOff: document.body.classList.contains('noPanels'),
          // bepaal huidige opaciteit van de afbeelding-overlay (als 0..1). Indien geen overlay aanwezig, gebruik 1.
          imageOpacity: (function(){
            const ov = document.getElementById('bgOverlay');
            if(!ov) return 1;
            const o = parseFloat(ov.style.opacity);
            return isNaN(o) ? 1 : o;
          })()
        };
      } catch(e) {
        // bij fouten gewoon een lege instellingenstructuur gebruiken
        settings = {};
      }
      backgroundsList.push({ id: crypto.randomUUID(), name: nm, url, settings });
      saveBackgrounds();
    }
    // Selecteer een opgeslagen achtergrond en stel deze in als huidige achtergrond.
    function useBackground(id){
      loadBackgrounds();
      const bg = backgroundsList.find(b => b.id === id);
      if(bg){
        // Pas de opgeslagen achtergrondafbeelding toe indien beschikbaar
        if(bg.url) setBgImage(bg.url);
        // Als er extra instellingen zijn opgeslagen bij deze achtergrond, pas ze dan toe
        if(bg.settings && typeof bg.settings === 'object'){
          const s = bg.settings;
          // tekstkleur
          if(s.textColor) setTextColor(s.textColor);
          // zijbalkkleur en transparantie
          if(s.asideColor) setAsideColor(s.asideColor);
          if(typeof s.asideOpacity === 'number') setAsideOpacity(s.asideOpacity * 100);
          // paneelkleuren en opaciteit
          if(s.panelColor) setPanelColor(s.panelColor);
          if(typeof s.panelOpacity === 'number') setPanelOpacity(s.panelOpacity);
          // aan/uit zetten van panelen
          if(typeof s.panelsOff === 'boolean') togglePanels(s.panelsOff);
          // opaciteit van afbeelding overlay
          if(typeof s.imageOpacity === 'number') setImageOpacity(Math.round(s.imageOpacity * 100));
        }
        // Na het toepassen van een nieuwe achtergrond, vernieuw de UI zodat sliders en kleurkiezers de juiste waarden tonen
        try { render(); } catch {}
      }
    }
    // Wijzig de naam van een opgeslagen achtergrond na een prompt. Vernieuw de UI door opnieuw te renderen.
    function renameBackground(id){
      loadBackgrounds();
      const bg = backgroundsList.find(b => b.id === id);
      if(!bg) return;
      const newName = prompt('Nieuwe naam voor deze achtergrond?', bg.name || '');
      if(newName && newName.trim()){
        bg.name = newName.trim();
        saveBackgrounds();
        render();
      }
    }
    // Verwijder een achtergrond na bevestiging en sla de gewijzigde lijst op. Vernieuw de UI.
    function deleteBackground(id){
      loadBackgrounds();
      if(!backgroundsList.length) return;
      if(confirm('Achtergrond verwijderen?')){
        backgroundsList = backgroundsList.filter(b => b.id !== id);
        saveBackgrounds();
        render();
      }
    }
    // Voorinstellingen voor achtergronden worden niet langer gebruikt. Gebruikers kiezen nu alleen een licht of donker thema of een eigen kleur.
    const PRESETS = [];
    function setBg(mode){
      // zet over naar licht of donker thema en verwijder afbeelding
      document.body.classList.remove('hasimg');
      document.body.classList.toggle('light', mode==='light');
      const bg = el('bg');
      if(bg) bg.style.backgroundImage = 'none';
      document.body.style.background = '';
      // verwijder overlay afbeelding
      const ov = document.getElementById('bgOverlay');
      if(ov){ ov.style.backgroundImage = 'none'; ov.style.opacity = 1; }
      localStorage.setItem(BKEY, JSON.stringify({type:'mode', mode}));
    }
    function setBgImage(url){
      // Zet een nieuwe achtergrondafbeelding. Als de URL relatief is, maak deze absoluut.
      let u = url;
      if(u && !u.startsWith('data:') && !/^https?:/.test(u)){
        try { u = new URL(u, location.href).href; } catch(e){}
      }
      // gebruik een overlay voor achtergrondafbeeldingen zodat de dekking kan worden aangepast
      const overlay = document.getElementById('bgOverlay');
      if(overlay){
        overlay.style.backgroundImage = u ? `url('${u}')` : '';
        // gebruik opgeslagen opacity indien beschikbaar
        try {
          const cfg = JSON.parse(localStorage.getItem(BKEY)||'{}');
          if(cfg && cfg.type==='image' && typeof cfg.opacity === 'number'){
            overlay.style.opacity = cfg.opacity;
          } else {
            overlay.style.opacity = 1;
          }
        } catch{ overlay.style.opacity = 1; }
      }
      // verwijder eventuele eerdere achtergrond op bg-div
      const bg = el('bg');
      if(bg) bg.style.backgroundImage = 'none';
      document.body.classList.add('hasimg');
      document.body.style.background = '';
      localStorage.setItem(BKEY, JSON.stringify({type:'image', url: u, opacity: (overlay? parseFloat(overlay.style.opacity):1)}));
    }

    // Pas de doorzichtigheid van de achtergrondafbeelding aan (0..100). Wordt opgeslagen bij de achtergrondinstellingen.
    function setImageOpacity(percent){
      const ov = document.getElementById('bgOverlay');
      if(!ov) return;
      // Range 0..100 -> 0..1
      const op = Math.max(0, Math.min(100, percent)) / 100;
      ov.style.opacity = op;
      // sla op in localStorage indien een afbeelding actief is
      try {
        const cfg = JSON.parse(localStorage.getItem(BKEY) || '{}');
        if(cfg && cfg.type === 'image'){
          cfg.opacity = op;
          localStorage.setItem(BKEY, JSON.stringify(cfg));
        }
      } catch {}
    }

    // --- tekst en zijbalk kleuren ---
    const TEXT_KEY = 'planner.text.color';
    const ASIDE_KEY = 'planner.aside.color';
const ASIDE_OPACITY_KEY = 'planner.aside.opacity';
    function setTextColor(hex){
      if(!hex) return;
      document.documentElement.style.setProperty('--text-color', hex);
      localStorage.setItem(TEXT_KEY, hex);
      // herteken de interface zodat nieuwe kleur overal wordt toegepast
      try {
        render();
      } catch {}
    }
    function getTextColor(){
      return localStorage.getItem(TEXT_KEY) || '';
    }
    function setAsideColor(hex){
      if(!hex) return;
      document.documentElement.style.setProperty('--aside-bg', hex);
      localStorage.setItem(ASIDE_KEY, hex);
    }

// Pas de transparantie van de zijbalk aan (0..100). Sla op in localStorage.
function setAsideOpacity(percent){
  // converteer percentage naar 0..1 bereik
  const op = Math.max(0, Math.min(100, percent)) / 100;
  document.documentElement.style.setProperty('--aside-opacity', op.toString());
  try {
    localStorage.setItem(ASIDE_OPACITY_KEY, op.toString());
  } catch {}
}

// Haal opgeslagen zijbalktransparantie op (als decimaal 0..1). Geeft 1 terug indien niet ingesteld.
function getAsideOpacity(){
  try {
    const v = localStorage.getItem(ASIDE_OPACITY_KEY);
    if(!v) return 1;
    const n = parseFloat(v);
    return isNaN(n) ? 1 : n;
  } catch {
    return 1;
  }
}
    function getAsideColor(){
      return localStorage.getItem(ASIDE_KEY) || '';
    }

    // ===== paneelkleur en transparantie =====
    // Opslagkeys voor paneelkleur en opaciteit
    const PANEL_COLOR_KEY = 'planner.panel.color';
    const PANEL_OPACITY_KEY = 'planner.panel.opacity';

    /**
     * Converteer een hex-kleur naar een rgba-string met een gegeven alpha.
     * @param {string} hex kleurcode, met of zonder '#'
     * @param {number|string} alpha transparantie tussen 0 en 1
     * @returns {string} rgba(...) string
     */
    function hexToRgba(hex, alpha){
      if(!hex) return '';
      let h = hex.replace('#', '');
      if(h.length === 3){
        h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
      }
      const r = parseInt(h.substring(0,2), 16) || 0;
      const g = parseInt(h.substring(2,4), 16) || 0;
      const b = parseInt(h.substring(4,6), 16) || 0;
      const a = typeof alpha === 'string' ? parseFloat(alpha) : alpha;
      const alp = (isNaN(a) ? 1 : Math.max(0, Math.min(1, a)));
      return `rgba(${r}, ${g}, ${b}, ${alp})`;
    }

    /**
     * Haal de opgeslagen paneelkleur op. Geeft een hex-string zonder alpha terug.
     */
    function getPanelColor(){
      try{
        return localStorage.getItem(PANEL_COLOR_KEY) || '';
      }catch{
        return '';
      }
    }

    /**
     * Haal de opgeslagen opaciteit op (0..1). Geeft 1 terug indien niets opgeslagen.
     */
    function getPanelOpacity(){
      try{
        const v = localStorage.getItem(PANEL_OPACITY_KEY);
        if(v === null || v === undefined) return 1;
        const n = parseFloat(v);
        return isNaN(n) ? 1 : n;
      }catch{
        return 1;
      }
    }

    /**
     * Pas de paneelachtergrondkleur toe op de document root. Combineert kleur en opaciteit.
     */
    function updatePanelBg(){
      try{
        const col = getPanelColor() || '#0b1220';
        const op = getPanelOpacity();
        const rgba = hexToRgba(col, op);
        document.documentElement.style.setProperty('--panel-bg', rgba);
      }catch{}
    }

    /**
     * Sla een nieuwe paneelkleur (hex) op en pas deze toe.
     */
    function setPanelColor(hex){
      if(!hex) return;
      try{
        localStorage.setItem(PANEL_COLOR_KEY, hex);
      }catch{}
      updatePanelBg();
    }

    /**
     * Sla een nieuwe paneelopaciteit op. Het argument kan een getal (0..100) of 0..1 zijn.
     */
    function setPanelOpacity(val){
      if(val === undefined || val === null) return;
      let num = parseFloat(val);
      // indien waarde groter dan 1, ga uit van percentage 0..100
      if(!isNaN(num) && num > 1){
        num = Math.max(0, Math.min(100, num)) / 100;
      }
      if(isNaN(num)) return;
      try{
        localStorage.setItem(PANEL_OPACITY_KEY, num.toString());
      }catch{}
      updatePanelBg();
    }
    function applySavedColors(){
      try {
        const tc = getTextColor();
        if(tc) document.documentElement.style.setProperty('--text-color', tc);
        const ac = getAsideColor();
        if(ac) document.documentElement.style.setProperty('--aside-bg', ac);
        // pas opgeslagen zijbalktransparantie toe
        try {
          const op = getAsideOpacity();
          if(op !== undefined) {
            document.documentElement.style.setProperty('--aside-opacity', op.toString());
          }
        } catch {}
        // pas opgeslagen paneelkleur en opaciteit toe
        updatePanelBg();
      } catch {}
    }

    // Hulp: zet een rgb/rgba string om naar een hex-string (zonder alpha).
    function rgbToHex(str){
      if(!str) return '#ffffff';
      const vals = str.replace(/rgba?\(|\)|\s/g, '').split(',');
      if(vals.length < 3) return '#ffffff';
      const r = parseInt(vals[0]) || 0;
      const g = parseInt(vals[1]) || 0;
      const b = parseInt(vals[2]) || 0;
      const toHex = v => ('0' + v.toString(16)).slice(-2);
      return '#' + toHex(r) + toHex(g) + toHex(b);
    }

    // Schakel paneelachtergronden uit of in. Wanneer uit, worden de meeste UI-elementen transparant zodat de achtergrond zichtbaar is.
    const PANELKEY='planner.ui.panelsOff';
    function togglePanels(off){
      const isOff = !!off;
      document.body.classList.toggle('noPanels', isOff);
      localStorage.setItem(PANELKEY, isOff ? '1' : '0');
    }

    // ================= roosterweergave instellingen =================
    // In de roosterweergave worden roostertaken altijd getoond, ongeacht de filterinstellingen.
    // Categorie√´n kunnen individueel worden aan- of uitgezet via de algemene filters.

    function initPanels(){
      const v = localStorage.getItem(PANELKEY) === '1';
      document.body.classList.toggle('noPanels', v);
    }
    function setBgColor(color){
      // eigen kleur als achtergrond instellen en overlay verwijderen
      document.body.classList.remove('hasimg');
      const bg = el('bg');
      if(bg) bg.style.backgroundImage = 'none';
      document.body.style.background = color;
      const ov = document.getElementById('bgOverlay');
      if(ov){ ov.style.backgroundImage = 'none'; ov.style.opacity = 1; }
      localStorage.setItem(BKEY, JSON.stringify({type:'color', color}));
    }

    // Helper om een hexkleur lichter te maken met een factor (0..1)
    function lightenColor(c, amt){
      if(!c || c[0] !== '#') return c;
      const num = parseInt(c.slice(1), 16);
      let r = (num >> 16) & 0xFF;
      let g = (num >> 8) & 0xFF;
      let b = num & 0xFF;
      r = Math.min(255, Math.round(r + (255 - r) * amt));
      g = Math.min(255, Math.round(g + (255 - g) * amt));
      b = Math.min(255, Math.round(b + (255 - b) * amt));
      return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
    }
    // Regenboogachtergrond. Toon een lineaire gradi√´nt over meerdere kleuren. Wanneer pastel=true, gebruik lichtere tinten.
    function setBgRainbow(pastel=false){
      document.body.classList.remove('hasimg');
      // verwijder afbeelding overlay
      const ov = document.getElementById('bgOverlay');
      if(ov){ ov.style.backgroundImage = 'none'; ov.style.opacity = 1; }
      // definieer basiskleuren voor regenboog
      const vividColors = ['#ff6666','#ffb366','#fff466','#66ff66','#66fff4','#6666ff','#b366ff','#ff66ff'];
      const pastelColors = ['#ffcccc','#ffe6cc','#ffffcc','#ccffcc','#ccffff','#ccccff','#e6ccff','#ffccff'];
      const base = pastel ? pastelColors : vividColors;
      // verhelderingsfactor: pastel = meer verhelderen; normaal = iets verhelderen zodat de kleuren niet te donker zijn
      // Verhoog de factor zodat de standaard regenboog lichter oogt en de pastelvariant nog zachter wordt
      const factor = pastel ? 0.65 : 0.35;
      const cols = base.map(c => lightenColor(c, factor));
      const gradient = 'linear-gradient(135deg,' + cols.join(',') + ')';
      document.body.style.background = gradient;
      // pastel regenboog activeert lichte modus
      document.body.classList.toggle('light', pastel);
      // sla de instelling op
      localStorage.setItem(BKEY, JSON.stringify({ type: pastel ? 'rainbowPastel' : 'rainbow' }));
    }
    function getBgColor(){try{const s=JSON.parse(localStorage.getItem(BKEY)||'{}');return s.type==='color'?s.color:null}catch{return null}}
(function initBg(){
  try {
    const c = JSON.parse(localStorage.getItem(BKEY) || '{}');
    if(c.type === 'mode') setBg(c.mode);
    if(c.type === 'image') setBgImage(c.url);
    if(c.type === 'color') setBgColor(c.color);
    if(c.type === 'rainbow') setBgRainbow(false);
    if(c.type === 'rainbowPastel') setBgRainbow(true);
  } catch {}
  // initialise transparante panelen zodra achtergrond is ingesteld
  try { initPanels(); } catch {}
  // pas opgeslagen kleuren toe
  try { applySavedColors(); } catch {}
})();

    // upload achtergrondafbeelding
    function handleBgUpload(ev){
      const file = ev.target.files && ev.target.files[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = function(e){
        const dataUrl = e.target.result;
        // Vraag om een naam voor deze achtergrond. Als de gebruiker niks invoert, gebruik de bestandsnaam of een standaardnaam.
        let defaultName = file.name || '';
        const nm = prompt('Naam voor deze achtergrond?', defaultName);
        // Voeg toe aan lijst en sla op
        addBackground(nm && nm.trim() ? nm.trim() : defaultName, dataUrl);
        // Stel de nieuwe afbeelding in als huidige achtergrond
        setBgImage(dataUrl);
        // Hernieuw de UI zodat de nieuwe achtergrond in de lijst verschijnt
        try { render(); } catch {}
      };
      reader.readAsDataURL(file);
    }
    // Firebase integratie
    let firebaseApp = null;
    let auth = null;
    async function initFirebase() {
      try {
        const cfg = JSON.parse(localStorage.getItem('planner.firebase.config') || '{}');
        if (cfg && cfg.apiKey) {
          const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js');
          const { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js');
          firebaseApp = initializeApp(cfg);
          auth = getAuth(firebaseApp);
          // Expose methods
          window._fbSignIn = signInWithEmailAndPassword;
          window._fbSignOut = signOut;
          window._fbOnAuth = onAuthStateChanged;
          window._fbAuth = auth;
          // Luister naar loginstate
          onAuthStateChanged(auth, user => {
            const title = document.getElementById('title');
            if (user) {
              title && (title.innerText = 'Kalender (ingelogd)');
            } else {
              title && (title.innerText = 'Kalender');
            }
          });
        }
      } catch (e) {
        console.warn('Fout bij initialiseren Firebase:', e);
      }
    }
    // initFirebase(); // Firebase inloggen is verwijderd; gegevens worden lokaal opgeslagen
    // Controleer of er een lokaal ingelogde gebruiker is wanneer Firebase niet wordt gebruikt.
    (function initLocalLogin(){
      try {
        const localUser = JSON.parse(localStorage.getItem('planner.localUser') || 'null');
        if (localUser && !auth) {
          // Als er geen Firebase-auth is maar wel een lokaal opgeslagen gebruiker, toon als ingelogd
          const title = document.getElementById('title');
          title && (title.innerText = 'Kalender (ingelogd)');
        }
      } catch (e) {
        console.warn('Kon lokale gebruiker niet initialiseren:', e);
      }
    })();
    // account (login/logout)
    window.loginLocal = async function() {
      const u = el('user')?.value;
      const p = el('pass')?.value;
      if (!u || !p) { alert('Voer een gebruikersnaam en wachtwoord in.'); return; }
      // Als Firebase-config bestaat, gebruik Firebase om in te loggen (gebruikersnaam wordt als e‚Äëmail beschouwd)
      if (auth) {
        try {
          await window._fbSignIn(auth, u, p);
          alert('Inloggen geslaagd');
          // Vernieuw de UI zodat de account-pagina wordt bijgewerkt
          try { if (typeof render === 'function') render(); } catch {}
        } catch (err) {
          alert('Fout bij inloggen: ' + (err.message || err));
        }
      } else {
        // Geen Firebase-config: controleer lokale gebruikers
        const users = getLocalUsers();
        const existing = users.find(x => x && x.username === u);
        if(!existing){
          alert('Gebruikersnaam niet gevonden.');
          return;
        }
        const hash = btoa(p);
        if(existing.pass !== hash){
          alert('Ongeldig wachtwoord.');
          return;
        }
        localStorage.setItem('planner.localUser', JSON.stringify({ username: u }));
        const title = document.getElementById('title');
        title && (title.innerText = 'Kalender (ingelogd)');
        alert('Ingelogd als ' + u);
        // Vernieuw de UI zodat de account-pagina wordt bijgewerkt
        try { if (typeof render === 'function') render(); } catch {}
      }
    }
    window.logoutLocal = async function() {
      // Als Firebase-auth beschikbaar is, gebruik Firebase signOut
      if (auth) {
        try {
          await window._fbSignOut(auth);
          alert('Uitgelogd');
          // Vernieuw de UI zodat de account-pagina wordt bijgewerkt
          try { if (typeof render === 'function') render(); } catch {}
        } catch (err) {
          alert('Fout bij uitloggen: ' + (err.message || err));
        }
      } else {
        // Anders verwijder lokaal opgeslagen gebruiker
        localStorage.removeItem('planner.localUser');
        const title = document.getElementById('title');
        title && (title.innerText = 'Kalender');
        alert('Uitgelogd');
        // Vernieuw de UI zodat de account-pagina wordt bijgewerkt
        try { if (typeof render === 'function') render(); } catch {}
      }
    }

    // ===== lokale gebruikersbeheer =====
    /**
     * Haal de lijst met lokale gebruikers op uit localStorage. Geeft een lege array terug wanneer er geen gebruikers zijn.
     * @returns {Array<{username:string, pass:string, hint?:string}>}
     */
    function getLocalUsers(){
      try {
        const arr = JSON.parse(localStorage.getItem('planner.localUsers') || '[]');
        return Array.isArray(arr) ? arr : [];
      } catch (e) {
        return [];
      }
    }

    /**
     * Sla de lijst met lokale gebruikers op in localStorage.
     * @param {Array<{username:string, pass:string}>} users
     */
    function saveLocalUsers(users){
      try {
        localStorage.setItem('planner.localUsers', JSON.stringify(users || []));
      } catch {}
    }

    /**
     * Maak een nieuwe lokale gebruiker aan op basis van het ingevulde formulier. De gebruikersnaam moet uniek zijn.
     * Na registratie wordt de gebruiker automatisch ingelogd.
     */
    window.registerLocal = function(){
      const u = el('user')?.value;
      const p = el('pass')?.value;
      // hint kan leeg zijn, gebruik voor wachtwoordherinnering
      const h = el('hint')?.value || '';
      if(!u || !p){
        alert('Voer een gebruikersnaam en wachtwoord in.');
        return;
      }
      const users = getLocalUsers();
      if(users.find(x => x && x.username === u)){
        alert('Gebruikersnaam bestaat al.');
        return;
      }
      const hash = btoa(p);
      users.push({ username: u, pass: hash, hint: h });
      saveLocalUsers(users);
      // sla huidige gebruiker op en log in
      localStorage.setItem('planner.localUser', JSON.stringify({ username: u }));
      const title = document.getElementById('title');
      title && (title.innerText = 'Kalender (ingelogd)');
      alert('Account aangemaakt en ingelogd als ' + u);
      // Vernieuw de UI zodat de account-pagina wordt bijgewerkt
      try { if (typeof render === 'function') render(); } catch {}
    }

    /**
     * Toon de bewaarde wachtwoordhint voor de ingevoerde gebruikersnaam.
     * De hint wordt tijdens registratie opgegeven en lokaal opgeslagen.
     */
    window.showHint = function(){
      const u = el('user')?.value;
      if(!u){
        alert('Voer een gebruikersnaam in.');
        return;
      }
      const users = getLocalUsers();
      const existing = users.find(x => x && x.username === u);
      if(!existing){
        alert('Gebruikersnaam niet gevonden.');
        return;
      }
      const hint = existing.hint || '';
      if(!hint){
        alert('Er is geen hint beschikbaar voor deze gebruiker.');
      } else {
        alert('Hint: ' + hint);
      }
    }

    /**
     * Verwijder het account van de momenteel ingelogde gebruiker.
     * Dit verwijdert de gebruikersgegevens uit localStorage en logt de gebruiker uit.
     */
    window.deleteLocalAccount = function(){
      try {
        const currentUser = JSON.parse(localStorage.getItem('planner.localUser') || 'null');
        if(!currentUser || !currentUser.username){
          alert('Geen gebruiker ingelogd.');
          return;
        }
        const username = currentUser.username;
        if(!confirm('Weet je zeker dat je je account wilt verwijderen? Dit kan niet ongedaan worden gemaakt.')){
          return;
        }
        // verwijder gebruiker uit lijst
        const users = getLocalUsers();
        const updated = users.filter(x => x && x.username !== username);
        saveLocalUsers(updated);
        // verwijder huidige gebruiker
        localStorage.removeItem('planner.localUser');
        const title = document.getElementById('title');
        title && (title.innerText = 'Kalender');
        alert('Account verwijderd');
        // Vernieuw de UI zodat de account-pagina wordt bijgewerkt
        try { if (typeof render === 'function') render(); } catch {}
      } catch (e){
        console.warn('Fout bij verwijderen account:', e);
        alert('Er trad een fout op bij het verwijderen van het account.');
      }
    }
    window.saveCfg = function() {
      try {
        const cfg = JSON.parse(el('fbCfg').value || '{}');
        localStorage.setItem('planner.firebase.config', JSON.stringify(cfg));
        alert('Config opgeslagen. Herlaad de pagina om te initialiseren.');
      } catch (e) {
        alert('Ongeldige JSON-configuratie');
      }
    }
    // Zoekfunctie voor agenda: markeert taken die overeenkomen met de query tijdelijk geel
    function searchAgenda(query){
      // verwijder eerdere highlights
      document.querySelectorAll('.pill.highlight').forEach(p => p.classList.remove('highlight'));
      const q = (query || '').trim().toLowerCase();
      if(!q) return;
      document.querySelectorAll('.pill').forEach(p => {
        if(p.textContent.toLowerCase().includes(q)){
          p.classList.add('highlight');
          setTimeout(() => p.classList.remove('highlight'), 3000);
        }
      });
    }

    // Zoekfunctie voor kalender: markeert dagstripes (taken) die overeenkomen met de query tijdelijk geel
    function searchCalendar(query){
      // verwijder eerdere highlights van stripes
      document.querySelectorAll('.stripe.highlight').forEach(s => s.classList.remove('highlight'));
      const q = (query || '').trim().toLowerCase();
      if(!q) return;
      document.querySelectorAll('.stripe').forEach(s => {
        const title = s.getAttribute('title') || '';
        if(title.toLowerCase().includes(q)){
          s.classList.add('highlight');
          // verwijder highlight na 3 seconden
          setTimeout(() => s.classList.remove('highlight'), 3000);
        }
      });
    }
    // boot
    load();
    loadGrades();
    loadSubjects();
    render();
    setupNotifications();
    // plan notificaties voor taken binnen 24 uur
    scheduleDueTasks();

    // Populate voices when they become available. Some browsers load voices asynchronously.
    try {
      speechSynthesis.onvoiceschanged = function(){ populateVoices(); };
    } catch(e) {
      // ignore if speechSynthesis is not supported
    }

    // ===== klok =====
    // Toon de huidige tijd (met seconden) bovenaan de zijbalk. Wordt elke seconde bijgewerkt.
    function updateClock(){
      const timeEl = document.getElementById('clock');
      const dateEl = document.getElementById('date');
      if(!timeEl) return;
      const now = new Date();
      const lang = getLang();
      let locale;
      if(lang === 'nl') locale = 'nl-NL';
      else if(lang === 'en') locale = 'en-GB';
      else if(lang === 'fr') locale = 'fr-FR';
      else if(lang === 'de') locale = 'de-DE';
      else locale = 'es-ES';
      // update de klok met uren, minuten en seconden
      timeEl.textContent = now.toLocaleTimeString(locale, { hour:'2-digit', minute:'2-digit', second:'2-digit' });
      // update de datum boven de klok (bijv. maandag 3 nov)
      if(dateEl){
        dateEl.textContent = now.toLocaleDateString(locale, { weekday:'long', day:'numeric', month:'long' });
      }
    }
    setInterval(updateClock, 1000);
    updateClock();
  </script>

  <!-- Bestandviewer: toont een bijlage boven op de interface. Dit element is verborgen totdat openAttachmentViewer wordt aangeroepen. -->
  <div id="fileViewer" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:2000;background:rgba(0,0,0,0.8);display:none;flex-direction:column;">
    <div style="background:#1e293b;color:#f8fafc;padding:8px 12px;display:flex;justify-content:space-between;align-items:center;">
      <span id="fileName" style="font-weight:bold;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:80%;"></span>
      <button type="button" onclick="closeAttachmentViewer()" style="background:none;border:none;color:#f8fafc;font-size:20px;cursor:pointer">‚úñ</button>
    </div>
    <iframe id="fileFrame" style="flex:1;border:none;width:100%;background:#fff"></iframe>
  </div>
</body>
</html>